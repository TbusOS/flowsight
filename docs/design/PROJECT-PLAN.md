# 🔭 FlowSight 项目规划书

> **一个专为理解大型代码库设计的跨平台 IDE**
> 
> 让你看到代码的"灵魂"——执行流、异步调用、数据结构关系
> 
> 首要支持 Linux 内核，IDE 稳定后再扩展 Android 等其他平台

---

## 📋 目录

1. [项目愿景](#1-项目愿景)
2. [核心价值主张](#2-核心价值主张)
3. [技术架构设计](#3-技术架构设计)
4. [技术选型](#4-技术选型)
5. [详细开发计划](#5-详细开发计划)
6. [里程碑定义](#6-里程碑定义)
7. [项目结构](#7-项目结构)
8. [核心算法设计](#8-核心算法设计)
9. [UI/UX 设计](#9-uiux-设计)
   - [9.5 国际化 (i18n) 设计](#95-国际化-i18n-设计)
10. [风险评估与应对](#10-风险评估与应对)
11. [资源估算](#11-资源估算)
12. [成功指标](#12-成功指标)

---

## 🎯 核心开发策略

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         开发策略：先落地，再扩展                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   第一阶段：IDE 落地 (v1.0)                                              │
│   ══════════════════════════                                             │
│   • 知识库：只支持 Linux 内核                                            │
│   • 平台：Windows 优先 → Linux → macOS                                  │
│   • 语言：简体中文 + 英文 (首发双语支持)                                 │
│   • 目标：把 IDE 完整落地、调试稳定、发布正式版                          │
│                                                                          │
│   第二阶段：知识扩展 (v2.0+)                                             │
│   ══════════════════════════                                             │
│   • IDE 稳定后，逐步添加 Android 知识库                                  │
│   • 再逐步添加其他语言和平台                                             │
│   • 稳扎稳打，每步充分测试                                               │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  v0.1 → v0.5 → v1.0          v1.5 → v2.0          v2.5 → v3.0   │   │
│   │   │       │       │            │       │            │       │    │   │
│   │   └───────┴───────┘            └───────┘            └───────┘    │   │
│   │    Linux 内核 + IDE             Android              其他        │   │
│   │    ════════════════             ════════             ════        │   │
│   │     当前阶段重点                 下一阶段             远期        │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 1. 项目愿景

### 1.1 问题陈述

当开发者面对 Linux 内核这样的超大型代码库（2000万+ 行）时，现有工具存在严重不足：

| 现有工具 | 能做什么 | 做不到什么 |
|----------|----------|------------|
| VS Code + clangd | 符号跳转、补全 | 看不到异步执行流、函数指针指向 |
| Source Insight | 符号索引、调用图 | 不理解内核异步机制 |
| Understand | 静态分析、度量 | 无法追踪回调绑定 |
| Sourcetrail | 可视化调用图 | 已停止维护，不理解语义 |

**核心痛点**：当代码出现以下模式时，所有 IDE 都"迷路"了：

```c
// 😵 现有 IDE 看到这里就断了
INIT_WORK(&dev->work, my_handler);    // 绑定
schedule_work(&dev->work);             // 触发 → ??? 谁被调用？

request_irq(irq, irq_handler, ...);    // 注册 → ??? 何时执行？

static struct file_operations fops = {
    .read = my_read,                    // 赋值 → ??? 谁调用 .read？
};
```

### 1.2 解决方案

**FlowSight** —— 一个能"看懂"代码执行流的 IDE：

- 🔍 **静态分析** = 不需要运行代码，纯代码阅读
- 🧠 **语义理解** = 理解异步机制、回调模式、函数指针
- 📊 **可视化** = 看到完整的执行流程图
- 🖥️ **跨平台** = Windows (首要) / Linux / macOS

### 1.3 目标用户

| 用户群体 | 使用场景 |
|----------|----------|
| Linux 内核开发者 | 理解子系统、审查补丁 |
| 驱动开发者 | 学习驱动框架、调试问题 |
| **Android 系统开发者** | 理解 Framework、追踪 Binder 调用 |
| **Android App 开发者** | 分析复杂的回调和协程流程 |
| 安全研究员 | 漏洞分析、攻击面评估 |
| 嵌入式开发者 | 理解 BSP、定制内核 |
| 学生/教育者 | 学习操作系统原理 |

---

## 2. 核心价值主张

### 2.1 差异化功能

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      FlowSight 核心功能矩阵                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   功能                          VS Code    Source Insight   FlowSight       │
│   ─────────────────────────────────────────────────────────────────────────  │
│   基础代码编辑                    ✅           ✅              ✅            │
│   符号跳转                        ✅           ✅              ✅            │
│   函数调用图                      ⚠️           ✅              ✅            │
│   ─────────────────────────────────────────────────────────────────────────  │
│   异步执行流可视化                ❌           ❌              ✅ 核心       │
│   函数指针解析                    ❌           ⚠️              ✅ 核心       │
│   回调绑定追踪                    ❌           ❌              ✅ 核心       │
│   执行上下文标注                  ❌           ❌              ✅ 核心       │
│   ─────────────────────────────────────────────────────────────────────────  │
│   内核框架知识库                  ❌           ❌              ✅            │
│   子系统边界可视化                ❌           ❌              ✅            │
│   数据结构生命周期                ❌           ❌              ✅            │
│   ─────────────────────────────────────────────────────────────────────────  │
│   Android Binder 追踪             ❌           ❌              ✅ v2.0       │
│   JNI 跨语言分析                  ❌           ❌              ✅ v2.0       │
│   Kotlin 协程可视化               ❌           ❌              ✅ v2.0       │
│   Android 生命周期追踪            ❌           ❌              ✅ v2.0       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 用户故事

**故事1：理解 USB 热插拔流程**

> 作为内核开发者，我想看到当 USB 设备插入时，从 hub_irq() 中断到我的驱动 probe() 
> 被调用的完整流程，包括中间经过的工作队列、tasklet，这样我能理解时序和上下文。

**故事2：追踪内存分配**

> 作为安全研究员，我想看到 kmalloc() 分配的内存在哪些函数中被使用，
> 最终在哪里被释放，这样我能发现潜在的 use-after-free。

**故事3：学习文件系统**

> 作为学生，我想看到当用户调用 read() 系统调用时，如何一步步到达 ext4 的 
> ext4_file_read_iter()，包括 VFS 层的回调机制。

---

## 3. 技术架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                             FlowSight                                        │
│                              整体架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           表现层 (Presentation)                         │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │                      Tauri 桌面应用                              │   │ │
│  │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐       │   │ │
│  │  │  │  编辑器   │ │  项目    │ │  流程图   │ │  结构图   │       │   │ │
│  │  │  │  Monaco   │ │  管理器  │ │  D3/ELK   │ │  关系图   │       │   │ │
│  │  │  └───────────┘ └───────────┘ └───────────┘ └───────────┘       │   │ │
│  │  │                      React + TypeScript                         │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     │ Tauri IPC / Commands                   │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           应用层 (Application)                          │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │ │
│  │  │   项目      │ │   查询     │ │   会话      │ │   配置      │      │ │
│  │  │   服务      │ │   服务     │ │   管理      │ │   管理      │      │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘      │ │
│  │                           Rust (Tauri Backend)                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           核心层 (Core)                                 │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐ │ │
│  │  │                       分析引擎 (flowsight-core)                         │ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    │ │ │
│  │  │  │ 解析器  │ │ 索引器  │ │ 类型    │ │ 调用图  │ │ 异步    │    │ │ │
│  │  │  │ Parser  │ │ Indexer │ │ System  │ │ Builder │ │ Tracker │    │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘    │ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐                            │ │ │
│  │  │  │ 函数    │ │ 数据流  │ │ 知识库  │                            │ │ │
│  │  │  │ 指针    │ │ 分析    │ │ 引擎    │                            │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘                            │ │ │
│  │  └───────────────────────────────────────────────────────────────────┘ │ │
│  │                              Rust                                       │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                          基础层 (Infrastructure)                        │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │ │
│  │  │ tree-sitter │ │  libclang   │ │   SQLite    │ │   sled      │      │ │
│  │  │ (快速解析)  │ │ (精确解析)  │ │  (符号表)   │ │  (调用图)   │      │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘      │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 核心模块设计

#### 3.2.1 解析引擎 (Parser)

```
解析引擎分层设计
═══════════════════════════════════════════════════════════════════════════════

Layer 1: 快速解析 (tree-sitter)
├── 用途: 实时语法高亮、增量编辑、快速预览
├── 特点: 纯 Rust，无外部依赖，毫秒级响应
└── 能力: 语法树、符号提取、基础调用识别

Layer 2: 精确解析 (libclang)  
├── 用途: 完整类型系统、宏展开、跨文件分析
├── 特点: 需要 compile_commands.json
├── 能力: 类型推导、typedef 展开、预处理
└── 触发: 用户主动请求或后台索引

Layer 3: 语义分析 (自研)
├── 用途: 异步机制识别、函数指针解析
├── 特点: 基于知识库的模式匹配
└── 能力: 执行流构建、回调追踪
```

#### 3.2.2 索引系统 (Indexer)

```
索引系统设计
═══════════════════════════════════════════════════════════════════════════════

索引类型                  存储            用途
─────────────────────────────────────────────────────────────────────────────
符号索引                  SQLite          函数、结构体、变量快速查找
调用图索引                sled (KV)       函数调用关系、调用链查询
异步绑定索引              sled            work/timer/irq 绑定关系
结构体关系索引            sled            字段引用、嵌套关系
文件依赖索引              SQLite          include 关系、编译单元

索引更新策略：
├── 增量更新: 文件修改时只更新受影响的索引
├── 后台索引: 大项目首次打开时后台构建
├── 优先级队列: 当前打开的文件优先索引
└── 持久化: 索引保存到磁盘，下次打开直接加载
```

#### 3.2.3 异步追踪器 (Async Tracker)

```
异步追踪器核心算法
═══════════════════════════════════════════════════════════════════════════════

输入: 源代码 + 知识库
输出: 异步绑定图

算法流程:

1. 扫描绑定点
   ├── 匹配知识库中的绑定模式
   │   INIT_WORK(&dev->work, handler) → 提取 (dev->work, handler)
   ├── 记录变量表达式和处理函数的关联
   └── 构建: BindingMap<VariableExpr, HandlerFunc>

2. 解析变量归属
   ├── 分析变量表达式的类型
   │   dev->work → dev 是 struct my_device* → work 是 struct work_struct
   ├── 建立结构体字段到处理函数的映射
   └── 构建: StructFieldMap<(StructType, Field), HandlerFunc>

3. 扫描触发点  
   ├── 匹配知识库中的触发模式
   │   schedule_work(&dev->work) → 提取 dev->work
   ├── 查询 BindingMap 找到对应的 handler
   └── 构建: TriggerEdge(caller, trigger_site, handler)

4. 构建执行流图
   ├── 将普通调用边和异步触发边合并
   ├── 标注执行上下文 (进程/软中断/硬中断)
   └── 输出: ExecutionFlowGraph
```

---

## 4. 技术选型

### 4.1 技术栈总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            技术栈选型                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  层次              技术                  理由                                │
│  ──────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  桌面框架          Tauri 2.0             • 体积小 (~10MB vs Electron 150MB) │
│                                          • 性能好 (Rust 后端)                │
│                                          • 跨平台 (Win/Linux/Mac)           │
│                                          • 安全性高                          │
│                                                                              │
│  前端框架          React 18 + TS         • 成熟稳定                          │
│                                          • 组件生态丰富                      │
│                                          • TypeScript 类型安全              │
│                                                                              │
│  代码编辑器        Monaco Editor         • VS Code 同款                     │
│                                          • 功能完整                          │
│                                          • 可深度定制                        │
│                                                                              │
│  可视化            D3.js + dagre         • 灵活强大                          │
│                    / ELK.js              • 支持复杂布局                      │
│                                                                              │
│  核心引擎          Rust                  • 性能关键                          │
│                                          • 内存安全                          │
│                                          • 与 clang 生态兼容                │
│                                                                              │
│  快速解析          tree-sitter           • 增量解析                          │
│                    (tree-sitter-c)       • 纯 Rust 实现                     │
│                                                                              │
│  精确解析          libclang              • 完整 C 语义                      │
│                    (clang-sys)           • 宏展开                            │
│                                          • 类型推导                          │
│                                                                              │
│  符号存储          SQLite                • 成熟可靠                          │
│                    (rusqlite)            • 全文搜索                          │
│                                                                              │
│  图存储            sled                  • 纯 Rust                          │
│                                          • 嵌入式 KV                         │
│                                          • 适合图遍历                        │
│                                                                              │
│  构建系统          Cargo + pnpm          • Rust 标准                        │
│                                          • 前端依赖管理                      │
│                                                                              │
│  CI/CD             GitHub Actions        • 自动构建多平台                    │
│                                          • 自动发布                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 为什么选择 Tauri 而不是 Electron

| 对比项 | Electron | Tauri |
|--------|----------|-------|
| 包体积 | ~150MB | ~10MB |
| 内存占用 | 高 (Chromium) | 低 (系统 WebView) |
| 启动速度 | 慢 | 快 |
| 后端语言 | Node.js | Rust |
| 安全性 | 一般 | 优秀 (沙箱) |
| 性能 | 一般 | 优秀 |
| 成熟度 | 非常成熟 | 2.0 已稳定 |

**结论**: Tauri 2.0 已经足够成熟，且 Rust 后端与我们的分析引擎天然契合。

### 4.3 平台支持优先级

#### 为什么 Windows 优先？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Windows 优先的核心理由                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  📊 用户使用场景分析                                                     │
│  ─────────────────────────                                               │
│                                                                          │
│  1. 大多数开发者在 Windows 上阅读代码                                   │
│     • 企业环境以 Windows 为主                                           │
│     • 个人开发者也多使用 Windows                                        │
│                                                                          │
│  2. 即使目标代码在 Linux 上，开发者仍用 Windows IDE                     │
│     • SSH 远程访问 Linux 服务器                                         │
│     • 本地 Windows IDE + 远程代码                                       │
│     • WSL2 + Windows IDE 组合                                           │
│                                                                          │
│  3. Linux 内核/Android 代码可以在任何平台分析                           │
│     • 静态分析不需要运行目标代码                                        │
│     • 代码可以 clone 到本地或挂载远程                                   │
│     • 编译产物可从 Linux 服务器导入                                     │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    典型使用场景                                    │  │
│  │                                                                    │  │
│  │   Windows 工作站                    Linux 服务器                   │  │
│  │  ┌─────────────────┐              ┌─────────────────┐             │  │
│  │  │  FlowSight IDE  │    SSH/NFS   │  Linux 内核源码  │             │  │
│  │  │  (分析+可视化)  │ ◄──────────► │  编译环境        │             │  │
│  │  └─────────────────┘              │  compile_commands│             │  │
│  │                                   └─────────────────┘             │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 平台支持路线图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       IDE 平台支持路线图                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  🥇 第一优先级: Windows                                                  │
│  ════════════════════════════                                            │
│  • 主要用户群体的首选平台                                                │
│  • 开发主力平台，功能最完整                                              │
│  • 测试覆盖最充分                                                        │
│  • 支持 WSL2 集成（可选）                                                │
│                                                                          │
│  🥈 第二优先级: Linux                                                    │
│  ════════════════════════════                                            │
│  • 部分开发者直接在 Linux 桌面工作                                       │
│  • 功能完全对齐 Windows 版本                                             │
│  • CI/CD 服务器环境                                                      │
│                                                                          │
│  🥉 第三优先级: macOS                                                    │
│  ════════════════════════════                                            │
│  • 部分开发者使用 Mac                                                    │
│  • 基于 Tauri 的跨平台特性自动支持                                       │
│  • 按需修复平台特定问题                                                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

| 平台 | 开发优先级 | 首次可用版本 | 完整支持版本 | 目标用户占比 |
|------|-----------|-------------|-------------|-------------|
| **Windows** | P0 (首先) | v0.1 (MVP) | v1.0 ✅ | ~60% |
| **Linux** | P1 (其次) | v0.2 | v1.0 ✅ | ~30% |
| **macOS** | P2 (最后) | v0.3 | v1.0 ✅ | ~10% |

> ⚠️ **重要**: v1.0 发布时**必须同时提供三个平台的安装包**。开发优先级仅影响开发顺序，不影响最终交付。

#### 最终交付物

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      v1.0 必须交付的安装包                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   Windows                                                                │
│   ├── flowsight-1.0.0-x64.msi          (MSI 安装包)                     │
│   ├── flowsight-1.0.0-x64-setup.exe    (NSIS 安装包)                    │
│   └── flowsight-1.0.0-x64.zip          (免安装版)                       │
│                                                                          │
│   Linux                                                                  │
│   ├── flowsight-1.0.0-amd64.deb        (Debian/Ubuntu)                  │
│   ├── flowsight-1.0.0-x86_64.rpm       (Fedora/RHEL)                    │
│   ├── flowsight-1.0.0-x86_64.AppImage  (通用)                           │
│   └── flowsight-1.0.0-x86_64.tar.gz    (免安装版)                       │
│                                                                          │
│   macOS                                                                  │
│   ├── flowsight-1.0.0-x64.dmg          (Intel Mac)                      │
│   ├── flowsight-1.0.0-aarch64.dmg      (Apple Silicon)                  │
│   └── flowsight-1.0.0-universal.dmg    (通用二进制，可选)               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

> **设计原则**: FlowSight 是一个**代码阅读和分析工具**，不需要运行目标代码。因此用户可以在 Windows 上分析 Linux 内核代码，就像使用 VS Code 阅读任何代码一样自然。

### 4.4 为什么使用 Rust 而不是 C++

| 对比项 | C++ | Rust |
|--------|-----|------|
| 内存安全 | 手动管理 | 编译期保证 |
| 并发安全 | 容易出错 | 类型系统保证 |
| 与 clang | 原生兼容 | clang-sys 绑定 |
| tree-sitter | C 绑定 | 原生 Rust 版本 |
| 开发效率 | 一般 | 较高 (cargo) |
| 社区 | 成熟 | 活跃增长 |

**结论**: Rust 在安全性和开发效率上有明显优势，且有成熟的 clang 和 tree-sitter 绑定。

---

## 5. 详细开发计划

### 5.1 总体时间线

```
2026                                    2027
Q1        Q2        Q3        Q4        Q1        Q2
│         │         │         │         │         │
▼         ▼         ▼         ▼         ▼         ▼
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│  P0     │   P1    │   P2    │   P3    │   P4    │   P5    │
│ 原型    │  核心   │  IDE    │  完善   │  高级   │  生态   │
│ 验证    │  引擎   │  基础   │  优化   │  功能   │  建设   │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
   MVP       Alpha     Beta    RC        v1.0      v1.x
```

### 5.2 Phase 0: 原型验证 (8 周)

**目标**: 验证核心技术可行性

```
Week 1-2: 环境搭建
════════════════════════════════════════════════════════════════════════════════

任务:
├── [ ] 项目仓库初始化
├── [ ] Rust workspace 结构
├── [ ] Tauri 项目脚手架
├── [ ] CI/CD 基础配置
└── [ ] 开发环境文档

产出:
├── GitHub 仓库
├── 基础构建可运行
└── 三平台编译通过


Week 3-4: tree-sitter 集成
════════════════════════════════════════════════════════════════════════════════

任务:
├── [ ] tree-sitter-c 集成
├── [ ] 基础 AST 遍历
├── [ ] 函数/结构体提取
├── [ ] 函数调用提取
└── [ ] 单元测试

产出:
├── flowsight-parser crate
├── 能解析简单 C 文件
└── 测试覆盖率 > 80%


Week 5-6: 异步模式识别原型
════════════════════════════════════════════════════════════════════════════════

任务:
├── [ ] 知识库 YAML 格式定义
├── [ ] 模式匹配引擎
├── [ ] work_struct 追踪
├── [ ] timer_list 追踪
└── [ ] 测试用例: USB 驱动

产出:
├── flowsight-async crate
├── 能识别常见异步模式
└── Demo: USB 驱动执行流输出


Week 7-8: 简单 UI 原型
════════════════════════════════════════════════════════════════════════════════

任务:
├── [ ] Tauri 窗口
├── [ ] Monaco 编辑器集成
├── [ ] 简单调用树显示
├── [ ] Rust 后端通信
└── [ ] 点击跳转

产出:
├── 可运行的桌面应用
├── 能打开文件、显示调用树
└── Phase 0 演示视频
```

### 5.3 Phase 1: 核心引擎 (12 周)

**目标**: 完成分析引擎核心功能

```
Month 1: 解析与索引
════════════════════════════════════════════════════════════════════════════════

Week 1-2: libclang 集成
├── [ ] clang-sys 绑定
├── [ ] compile_commands.json 支持
├── [ ] 宏展开
├── [ ] typedef 解析
└── [ ] 精确类型信息

Week 3-4: 索引系统
├── [ ] SQLite 符号表
├── [ ] sled 调用图存储
├── [ ] 增量索引机制
├── [ ] 后台索引线程
└── [ ] 索引持久化


Month 2: 调用图与异步分析
════════════════════════════════════════════════════════════════════════════════

Week 5-6: 调用图构建
├── [ ] 直接调用边
├── [ ] 间接调用边 (函数指针)
├── [ ] 调用链查询
├── [ ] 被调用查询
└── [ ] 循环检测

Week 7-8: 异步追踪完善
├── [ ] 完整模式库 (15+ 模式)
│   ├── work_struct / delayed_work
│   ├── timer_list / hrtimer
│   ├── tasklet / softirq
│   ├── request_irq / threaded_irq
│   ├── kthread
│   ├── rcu_callback
│   ├── completion
│   └── notifier_chain
├── [ ] 变量归属分析
├── [ ] 跨函数追踪
└── [ ] 上下文推断


Month 3: 函数指针解析
════════════════════════════════════════════════════════════════════════════════

Week 9-10: ops 表解析
├── [ ] 结构体初始化识别
├── [ ] .field = func 模式
├── [ ] 常见框架知识库
│   ├── file_operations
│   ├── usb_driver
│   ├── platform_driver
│   ├── i2c_driver
│   ├── net_device_ops
│   └── block_device_operations
└── [ ] 回调时机标注

Week 11-12: 高级函数指针
├── [ ] 变量赋值追踪
├── [ ] 类型签名匹配
├── [ ] 结构体成员赋值
├── [ ] 参数传递追踪
└── [ ] 置信度评分
```

### 5.4 Phase 2: IDE 基础 (12 周)

**目标**: 完成可用的 IDE 界面

```
Month 4: 编辑器完善
════════════════════════════════════════════════════════════════════════════════

Week 13-14: Monaco 深度集成
├── [ ] 语法高亮 (tree-sitter)
├── [ ] 自动补全
├── [ ] 悬浮提示
├── [ ] 跳转定义
├── [ ] 查找引用
└── [ ] 符号大纲

Week 15-16: 项目管理
├── [ ] 项目创建向导
├── [ ] 文件树视图
├── [ ] 多标签编辑
├── [ ] 搜索功能 (文件/符号)
├── [ ] 最近项目
└── [ ] 项目配置


Month 5: 可视化
════════════════════════════════════════════════════════════════════════════════

Week 17-18: 执行流图
├── [ ] 调用图布局 (dagre/ELK)
├── [ ] 节点样式 (普通/异步/回调)
├── [ ] 边样式 (同步/异步)
├── [ ] 缩放平移
├── [ ] 节点点击跳转
└── [ ] 路径高亮

Week 19-20: 交互增强
├── [ ] 展开/折叠
├── [ ] 搜索过滤
├── [ ] 层级控制
├── [ ] 上下文信息面板
├── [ ] 执行上下文标签
└── [ ] 导出 SVG/PNG


Month 6: 结构体与集成
════════════════════════════════════════════════════════════════════════════════

Week 21-22: 结构体关系图
├── [ ] 结构体可视化
├── [ ] 字段展示
├── [ ] 引用关系连线
├── [ ] 嵌套结构体
├── [ ] 与编辑器联动
└── [ ] 字段使用追踪

Week 23-24: 功能集成
├── [ ] 右键菜单
├── [ ] 快捷键系统
├── [ ] 命令面板
├── [ ] 状态栏
├── [ ] 通知系统
└── [ ] Beta 版本发布
```

### 5.5 Phase 3: 完善优化 (12 周)

**目标**: 性能优化、用户体验提升

```
Month 7: 性能优化
════════════════════════════════════════════════════════════════════════════════

├── [ ] 大项目索引优化 (Linux 内核)
├── [ ] 内存使用优化
├── [ ] 渲染性能优化
├── [ ] 索引增量更新
├── [ ] 懒加载机制
└── [ ] 性能监控


Month 8: 用户体验
════════════════════════════════════════════════════════════════════════════════

├── [ ] 主题系统 (亮/暗)
├── [ ] 字体/颜色配置
├── [ ] 布局自定义
├── [ ] 设置界面
├── [ ] 快捷键自定义
└── [ ] 新手引导


Month 9: 稳定性
════════════════════════════════════════════════════════════════════════════════

├── [ ] 错误处理完善
├── [ ] 崩溃恢复
├── [ ] 日志系统
├── [ ] 自动更新
├── [ ] 多语言支持
└── [ ] RC 版本发布
```

### 5.6 Phase 4: 高级功能 (12 周)

**目标**: 差异化高级功能

```
Month 10: 数据流分析
════════════════════════════════════════════════════════════════════════════════

├── [ ] 变量使用追踪
├── [ ] 内存生命周期
├── [ ] 污点分析基础
├── [ ] 数据流可视化
└── [ ] 潜在问题标注


Month 11: 知识库扩展
════════════════════════════════════════════════════════════════════════════════

├── [ ] 用户自定义模式
├── [ ] 社区模式共享
├── [ ] 内核版本适配
├── [ ] 框架文档集成
└── [ ] API 使用建议


Month 12: 协作与导出
════════════════════════════════════════════════════════════════════════════════

├── [ ] 分析结果导出
├── [ ] 报告生成
├── [ ] 书签/注释
├── [ ] 项目分享
└── [ ] v1.0 正式发布
```

### 5.7 Phase 5: Android 系统支持 (16 周)

**目标**: 全面支持 Android 系统代码分析

```
Month 13-14: Java/Kotlin 解析器
════════════════════════════════════════════════════════════════════════════════

├── [ ] tree-sitter-java 集成
├── [ ] tree-sitter-kotlin 集成
├── [ ] Java 符号提取与类型分析
├── [ ] Kotlin 协程识别
│     ├── suspend 函数标记
│     ├── launch/async 边界
│     └── withContext 上下文切换
├── [ ] Android 生命周期知识库
│     ├── Activity 生命周期
│     ├── Fragment 生命周期
│     ├── Service 生命周期
│     └── BroadcastReceiver 生命周期
└── [ ] Handler/Looper 异步模式


Month 15: Binder IPC 分析
════════════════════════════════════════════════════════════════════════════════

├── [ ] AIDL 接口解析
│     ├── 解析 .aidl 文件
│     ├── 生成的 Stub/Proxy 关联
│     └── onTransact 方法映射
├── [ ] Binder 调用追踪
│     ├── 客户端 → Stub.asInterface() 识别
│     ├── 服务端实现查找
│     └── 跨进程调用可视化
├── [ ] HIDL 接口分析 (HAL 层)
│     ├── .hal 文件解析
│     ├── HAL 实现查找
│     └── hwbinder 调用追踪
└── [ ] ServiceManager 服务注册追踪


Month 16: JNI 跨语言分析
════════════════════════════════════════════════════════════════════════════════

├── [ ] JNI 边界检测
│     ├── native 方法声明识别
│     ├── Java_xxx_xxx 函数匹配
│     └── RegisterNatives 动态注册解析
├── [ ] 类型映射
│     ├── Java ↔ JNI 类型转换
│     ├── 参数传递追踪
│     └── 回调方向识别
├── [ ] 跨语言调用图
│     ├── Java → Native 路径
│     ├── Native → Java 回调
│     └── 完整调用链可视化
└── [ ] JNI 性能建议


Month 17: Android 全栈集成
════════════════════════════════════════════════════════════════════════════════

├── [ ] 多进程架构可视化
│     ├── App 进程
│     ├── System Server
│     ├── 服务进程
│     └── Native 进程
├── [ ] 端到端执行流
│     ├── UI 事件 → Framework → Native → HAL → Kernel
│     ├── 完整调用路径
│     └── 异步边界标注
├── [ ] Android 项目导入
│     ├── Gradle 项目识别
│     ├── 多模块支持
│     └── NDK 项目集成
├── [ ] Android 专用知识库
│     ├── Framework 常用回调
│     ├── 系统服务接口
│     └── 常见设计模式
└── [ ] 与 Android Studio 协作模式
```

### 5.8 Phase 6: 生态建设 (持续)

```
持续任务:
├── [ ] 文档完善
├── [ ] 教程视频
├── [ ] 社区建设
├── [ ] 插件系统
├── [ ] 更多语言支持 (Rust for Linux, Go, Python)
├── [ ] 企业版功能
└── [ ] 其他系统支持 (iOS, 嵌入式 RTOS)
```

---

## 6. 里程碑定义

### 6.1 里程碑总览

| 里程碑 | 时间 | 目标 | 交付物 |
|--------|------|------|--------|
| M0 | P0 结束 | 技术验证 | 演示原型 |
| M1 | P1 结束 | 核心引擎 | CLI 分析工具 |
| M2 | P2 结束 | IDE Beta | 可用的桌面 IDE |
| M3 | P3 结束 | RC 版本 | 稳定可发布版 |
| M4 | P4 结束 | v1.0 | 正式版发布 |
| **M5** | **P5 结束** | **Android 支持** | **v2.0 多语言版** |

### 6.2 详细里程碑标准

#### M0: 技术验证 (Week 8)

```
验收标准:
├── [x] 能解析 Linux 驱动代码
├── [x] 能识别 INIT_WORK/schedule_work 关系
├── [x] 能输出执行流 JSON
├── [x] 有基本 UI 展示
└── [x] Windows 优先，三平台可编译

演示场景:
├── 打开 USB 驱动源码
├── 显示 probe 函数调用树
├── 显示工作队列回调关系
└── 点击跳转到代码
```

#### M1: 核心引擎 (Week 20)

```
验收标准:
├── [x] 完整的异步模式识别 (15+ 模式)
├── [x] 函数指针解析 (ops 表)
├── [x] 跨文件索引
├── [x] 调用链查询 < 100ms
├── [x] Linux 内核索引 < 10 分钟
└── [x] 内存占用 < 4GB

CLI 功能:
├── flowsight index /path/to/kernel
├── flowsight query call-chain func_a func_b
├── flowsight query async-handlers
└── flowsight export --format json/dot
```

#### M2: IDE Beta (Week 32)

```
验收标准:
├── [x] 完整的代码编辑体验
├── [x] 执行流可视化
├── [x] 结构体关系图
├── [x] 符号搜索 < 50ms
├── [x] UI 响应 < 100ms
└── [x] 无阻塞主线程

功能完整度:
├── 编辑器: 90%
├── 可视化: 80%
├── 项目管理: 70%
└── 配置: 60%
```

#### M3: RC 版本 (Week 44)

```
验收标准:
├── [x] 无 P0/P1 Bug
├── [x] 性能达标
├── [x] 内存稳定
├── [x] 崩溃率 < 0.1%
├── [x] 文档完整
└── [x] 测试覆盖 > 70%
```

#### M4: v1.0 正式版 (Week 56)

```
验收标准:
├── [x] 功能完整
├── [x] 用户手册
├── [x] 自动更新机制
├── [x] 社区反馈正面
└── [x] 官网上线

三平台安装包 (必须全部提供):
├── [x] Windows
│     ├── .msi 安装包
│     ├── .exe (NSIS) 安装包
│     └── .zip 免安装版
├── [x] Linux
│     ├── .deb (Debian/Ubuntu)
│     ├── .rpm (Fedora/RHEL)
│     ├── .AppImage (通用)
│     └── .tar.gz 免安装版
└── [x] macOS
      ├── .dmg (Intel x64)
      └── .dmg (Apple Silicon aarch64)
```

#### M5: v2.0 Android 支持 (Week 72)

```
验收标准:
├── [ ] Java/Kotlin 解析完整
├── [ ] Android 生命周期追踪
├── [ ] Binder IPC 分析可用
├── [ ] JNI 跨语言调用追踪
├── [ ] AOSP 索引 < 30 分钟
└── [ ] Android 知识库 > 50 个模式

演示场景:
├── 打开 AOSP SystemServer 代码
├── 显示 ActivityManagerService 调用图
├── 追踪 Binder 跨进程调用
│     ├── App 进程 startActivity()
│     ├── → Binder → System Server
│     ├── → ActivityManagerService
│     └── 显示完整调用链
├── 追踪 JNI 调用
│     ├── Java Camera.open()
│     ├── → JNI → CameraClient
│     ├── → HAL → Kernel Driver
│     └── 跨语言执行流可视化
└── Kotlin 协程执行流
      ├── launch { } 边界识别
      ├── suspend 函数调用链
      └── Dispatcher 上下文切换

Android 专项功能:
├── Activity/Fragment 生命周期图
├── Handler/Looper 消息追踪
├── 跨进程调用关系图
├── Native Crash 调用栈分析
└── ANR 分析辅助
```

---

## 7. 项目结构

### 7.1 仓库结构

```
flowsight/
├── .github/
│   ├── workflows/
│   │   ├── ci.yml              # 持续集成
│   │   ├── release.yml         # 发布流程
│   │   └── nightly.yml         # 每日构建
│   └── ISSUE_TEMPLATE/
│
├── crates/                      # Rust 核心库
│   ├── flowsight-core/               # 核心类型和接口
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── types.rs        # 基础类型定义
│   │   │   ├── error.rs        # 错误类型
│   │   │   └── config.rs       # 配置管理
│   │   └── Cargo.toml
│   │
│   ├── flowsight-parser/             # 解析器
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── treesitter.rs   # tree-sitter 后端
│   │   │   ├── clang.rs        # libclang 后端
│   │   │   ├── ast.rs          # AST 定义
│   │   │   └── visitor.rs      # AST 遍历
│   │   └── Cargo.toml
│   │
│   ├── flowsight-index/              # 索引系统
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── symbol.rs       # 符号索引
│   │   │   ├── callgraph.rs    # 调用图索引
│   │   │   ├── storage.rs      # 存储抽象
│   │   │   └── incremental.rs  # 增量更新
│   │   └── Cargo.toml
│   │
│   ├── flowsight-analysis/           # 分析引擎
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── async_tracker.rs    # 异步追踪
│   │   │   ├── funcptr.rs          # 函数指针解析
│   │   │   ├── dataflow.rs         # 数据流分析
│   │   │   ├── callchain.rs        # 调用链
│   │   │   └── context.rs          # 执行上下文
│   │   └── Cargo.toml
│   │
│   ├── flowsight-knowledge/          # 知识库
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── patterns.rs     # 模式匹配
│   │   │   ├── frameworks.rs   # 框架定义
│   │   │   └── loader.rs       # 加载器
│   │   ├── data/
│   │   │   ├── async_patterns.yaml
│   │   │   ├── frameworks/
│   │   │   │   ├── usb.yaml
│   │   │   │   ├── pci.yaml
│   │   │   │   ├── char_dev.yaml
│   │   │   │   └── ...
│   │   │   └── kernel_api.yaml
│   │   └── Cargo.toml
│   │
│   ├── flowsight-query/              # 查询引擎
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── engine.rs       # 查询执行
│   │   │   └── filter.rs       # 过滤器
│   │   └── Cargo.toml
│   │
│   └── flowsight-cli/                # 命令行工具
│       ├── src/
│       │   └── main.rs
│       └── Cargo.toml
│
├── app/                        # Tauri 桌面应用
│   ├── src-tauri/              # Tauri Rust 后端
│   │   ├── src/
│   │   │   ├── main.rs
│   │   │   ├── commands.rs     # Tauri 命令
│   │   │   ├── state.rs        # 应用状态
│   │   │   └── ipc.rs          # IPC 通信
│   │   ├── Cargo.toml
│   │   └── tauri.conf.json
│   │
│   └── src/                    # React 前端
│       ├── main.tsx
│       ├── App.tsx
│       │
│       ├── components/         # UI 组件
│       │   ├── layout/         # 布局组件 (可扩展架构)
│       │   │   ├── AppShell.tsx        # 应用外壳
│       │   │   ├── LayoutManager.tsx   # 布局管理器
│       │   │   ├── Sidebar.tsx         # 侧边栏容器
│       │   │   ├── Panel.tsx           # 通用面板
│       │   │   ├── PanelGroup.tsx      # 面板组 (可拖拽)
│       │   │   ├── StatusBar.tsx       # 状态栏
│       │   │   └── Toolbar.tsx         # 工具栏
│       │   │
│       │   ├── panels/         # 面板组件 (插件化设计)
│       │   │   ├── Explorer/           # 文件浏览器
│       │   │   │   ├── FileTree.tsx
│       │   │   │   ├── FileItem.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Editor/             # 代码编辑器
│       │   │   │   ├── EditorTabs.tsx
│       │   │   │   ├── MonacoEditor.tsx
│       │   │   │   ├── EditorToolbar.tsx
│       │   │   │   └── index.ts
│       │   │   ├── FlowView/           # 执行流视图
│       │   │   │   ├── FlowCanvas.tsx
│       │   │   │   ├── FlowNode.tsx
│       │   │   │   ├── FlowEdge.tsx
│       │   │   │   ├── FlowLegend.tsx
│       │   │   │   └── index.ts
│       │   │   ├── StructView/         # 结构体关系图
│       │   │   │   ├── StructGraph.tsx
│       │   │   │   ├── StructNode.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Outline/            # 代码大纲
│       │   │   │   ├── OutlineTree.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Search/             # 全局搜索
│       │   │   │   ├── SearchInput.tsx
│       │   │   │   ├── SearchResults.tsx
│       │   │   │   └── index.ts
│       │   │   ├── CallHierarchy/      # 调用层次
│       │   │   │   ├── CallTree.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Properties/         # 属性面板
│       │   │   │   ├── PropertyList.tsx
│       │   │   │   └── index.ts
│       │   │   │
│       │   │   └── _future/            # 未来功能占位
│       │   │       ├── Terminal/       # 终端 (v1.5)
│       │   │       ├── SSHExplorer/    # SSH (v2.0)
│       │   │       └── Debugger/       # 调试器 (v3.0)
│       │   │
│       │   └── common/         # 通用 UI 组件
│       │       ├── Button.tsx
│       │       ├── Input.tsx
│       │       ├── Tabs.tsx
│       │       ├── Modal.tsx
│       │       ├── ContextMenu.tsx
│       │       ├── Tooltip.tsx
│       │       ├── Tree.tsx
│       │       └── Icon.tsx
│       │
│       ├── i18n/               # 国际化
│       │   ├── index.ts        # i18n 配置
│       │   ├── locales/
│       │   │   ├── zh-CN.json  # 简体中文 (首选)
│       │   │   ├── en-US.json  # 英文
│       │   │   └── _template.json  # 翻译模板
│       │   └── useLocale.ts    # 语言切换 Hook
│       │
│       ├── services/           # 服务层 (业务逻辑)
│       │   ├── ProjectService.ts
│       │   ├── AnalysisService.ts
│       │   ├── FileService.ts
│       │   ├── SearchService.ts
│       │   ├── ThemeService.ts
│       │   ├── KeybindingService.ts
│       │   ├── LayoutService.ts
│       │   └── LocaleService.ts  # 语言服务
│       │
│       ├── stores/             # 状态管理 (Zustand)
│       │   ├── projectStore.ts
│       │   ├── editorStore.ts
│       │   ├── uiStore.ts
│       │   ├── layoutStore.ts
│       │   └── analysisStore.ts
│       │
│       ├── hooks/              # React Hooks
│       │   ├── useProject.ts
│       │   ├── useAnalysis.ts
│       │   ├── useEditor.ts
│       │   ├── useTheme.ts
│       │   ├── useKeybinding.ts
│       │   └── usePanel.ts
│       │
│       ├── styles/             # 样式
│       │   ├── globals.css     # 全局样式 + CSS 变量
│       │   ├── themes/
│       │   │   ├── dark.css
│       │   │   └── light.css
│       │   └── components/     # 组件样式
│       │
│       ├── types/              # TypeScript 类型定义
│       │   ├── panel.ts
│       │   ├── analysis.ts
│       │   ├── project.ts
│       │   └── ipc.ts
│       │
│       └── utils/              # 工具函数
│           ├── ipc.ts          # Tauri IPC 封装
│           ├── keybindings.ts  # 快捷键处理
│           └── layout.ts       # 布局工具
│
├── docs/                       # 文档
│   ├── user-guide/
│   ├── developer/
│   ├── api/
│   └── knowledge-base/
│
├── tests/                      # 集成测试
│   ├── fixtures/               # 测试用例代码
│   │   ├── simple_driver.c
│   │   ├── usb_driver/
│   │   └── kernel_subset/
│   └── integration/
│
├── scripts/                    # 构建脚本
│   ├── build.sh
│   ├── package.sh
│   └── test.sh
│
├── Cargo.toml                  # Rust workspace
├── package.json                # 前端依赖
├── pnpm-workspace.yaml
├── README.md
└── LICENSE
```

### 7.2 模块依赖关系

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          模块依赖关系                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                           ┌──────────────┐                                  │
│                           │   flowsight-cli    │                                  │
│                           └──────┬───────┘                                  │
│                                  │                                          │
│                           ┌──────▼───────┐                                  │
│                           │  flowsight-query   │                                  │
│                           └──────┬───────┘                                  │
│                                  │                                          │
│           ┌──────────────────────┼──────────────────────┐                  │
│           │                      │                      │                   │
│    ┌──────▼───────┐      ┌──────▼───────┐      ┌──────▼───────┐           │
│    │ flowsight-analysis │      │  flowsight-index   │      │flowsight-knowledge │           │
│    └──────┬───────┘      └──────┬───────┘      └──────┬───────┘           │
│           │                      │                      │                   │
│           └──────────────────────┼──────────────────────┘                  │
│                                  │                                          │
│                           ┌──────▼───────┐                                  │
│                           │  flowsight-parser  │                                  │
│                           └──────┬───────┘                                  │
│                                  │                                          │
│                           ┌──────▼───────┐                                  │
│                           │   flowsight-core   │                                  │
│                           └──────────────┘                                  │
│                                                                              │
│  外部依赖:                                                                   │
│  ─────────────────────────────────────────────────────────                  │
│  flowsight-parser: tree-sitter, tree-sitter-c, clang-sys                          │
│  flowsight-index: rusqlite, sled                                                  │
│  flowsight-knowledge: serde_yaml                                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 8. 核心算法设计

### 8.1 异步绑定追踪算法

```rust
/// 异步绑定追踪器
/// 
/// 核心思想：
/// 1. 扫描代码找到所有 "绑定点" (如 INIT_WORK)
/// 2. 扫描代码找到所有 "触发点" (如 schedule_work)
/// 3. 通过变量表达式将它们关联起来

pub struct AsyncTracker {
    /// 知识库中的异步模式
    patterns: Vec<AsyncPattern>,
    /// 变量 -> 处理函数 的绑定
    bindings: HashMap<VariableExpr, BindingInfo>,
    /// 类型系统引用
    type_system: Arc<TypeSystem>,
}

impl AsyncTracker {
    /// 分析单个文件
    pub fn analyze_file(&mut self, file: &ParsedFile) -> Vec<AsyncBinding> {
        let mut results = Vec::new();
        
        // 第一遍：收集所有绑定
        for func in &file.functions {
            for stmt in &func.body {
                for pattern in &self.patterns {
                    if let Some(binding) = self.match_bind_pattern(stmt, pattern) {
                        self.bindings.insert(binding.variable.clone(), binding.clone());
                    }
                }
            }
        }
        
        // 第二遍：匹配触发点
        for func in &file.functions {
            for stmt in &func.body {
                for pattern in &self.patterns {
                    if let Some(trigger) = self.match_trigger_pattern(stmt, pattern) {
                        // 查找对应的绑定
                        if let Some(binding) = self.resolve_binding(&trigger.variable) {
                            results.push(AsyncBinding {
                                mechanism: pattern.mechanism.clone(),
                                handler: binding.handler.clone(),
                                bind_location: binding.location.clone(),
                                trigger_location: trigger.location.clone(),
                                trigger_caller: func.name.clone(),
                                context: pattern.context.clone(),
                            });
                        }
                    }
                }
            }
        }
        
        results
    }
    
    /// 解析变量绑定
    /// 
    /// 处理以下情况：
    /// 1. 直接变量: &dev->work
    /// 2. 结构体字段: 通过类型系统找到结构体定义
    /// 3. 局部别名: work_ptr = &dev->work
    fn resolve_binding(&self, var: &VariableExpr) -> Option<&BindingInfo> {
        // 首先直接查找
        if let Some(binding) = self.bindings.get(var) {
            return Some(binding);
        }
        
        // 尝试规范化变量表达式
        let normalized = self.normalize_variable(var);
        if let Some(binding) = self.bindings.get(&normalized) {
            return Some(binding);
        }
        
        // 尝试通过类型系统解析
        if let Some(field_path) = self.resolve_struct_field(var) {
            for (key, binding) in &self.bindings {
                if self.is_same_field(&field_path, key) {
                    return Some(binding);
                }
            }
        }
        
        None
    }
    
    /// 规范化变量表达式
    /// 
    /// 例如：
    /// &dev->work     -> (dev, work)
    /// &(*dev).work   -> (dev, work)
    /// dev->inner.work -> (dev, inner.work)
    fn normalize_variable(&self, var: &VariableExpr) -> VariableExpr {
        // 移除 &
        // 转换 -> 为 .
        // 处理 (*ptr) 形式
        // ...
        todo!()
    }
}
```

### 8.2 函数指针解析算法

```rust
/// 函数指针解析器
/// 
/// 策略优先级：
/// 1. ops 表直接赋值 (.field = func)
/// 2. 变量赋值追踪
/// 3. 类型签名匹配
/// 4. 知识库启发式

pub struct FuncPtrResolver {
    /// 已知的 ops 表映射
    ops_mappings: HashMap<(StructType, FieldName), FunctionName>,
    /// 变量赋值图
    assignment_graph: AssignmentGraph,
    /// 类型系统
    type_system: Arc<TypeSystem>,
    /// 知识库
    knowledge: Arc<KnowledgeBase>,
}

impl FuncPtrResolver {
    /// 解析 ops 表
    /// 
    /// 匹配模式:
    /// static struct xxx_ops my_ops = {
    ///     .open = my_open,
    ///     .read = my_read,
    /// };
    pub fn parse_ops_table(&mut self, init: &StructInit) -> Vec<FuncPtrMapping> {
        let mut mappings = Vec::new();
        
        for field_init in &init.fields {
            if let Some(func_name) = self.extract_function_name(&field_init.value) {
                let mapping = FuncPtrMapping {
                    struct_type: init.struct_type.clone(),
                    field: field_init.field.clone(),
                    target_func: func_name,
                    location: field_init.location.clone(),
                    confidence: Confidence::High,
                };
                
                // 添加到全局映射
                self.ops_mappings.insert(
                    (init.struct_type.clone(), field_init.field.clone()),
                    func_name,
                );
                
                mappings.push(mapping);
            }
        }
        
        mappings
    }
    
    /// 解析间接调用
    /// 
    /// 例如: ops->read(file, buf, count)
    pub fn resolve_indirect_call(&self, call: &IndirectCall) -> Vec<ResolvedTarget> {
        let mut targets = Vec::new();
        
        // 策略1: 查找已知的 ops 映射
        if let Some(func) = self.lookup_ops_mapping(call) {
            targets.push(ResolvedTarget {
                function: func,
                confidence: Confidence::High,
                reason: "ops table mapping",
            });
            return targets;
        }
        
        // 策略2: 追踪变量赋值
        if let Some(assignments) = self.track_assignments(call) {
            for func in assignments {
                targets.push(ResolvedTarget {
                    function: func,
                    confidence: Confidence::Medium,
                    reason: "assignment tracking",
                });
            }
            if !targets.is_empty() {
                return targets;
            }
        }
        
        // 策略3: 类型签名匹配
        if let Some(candidates) = self.match_by_signature(call) {
            for func in candidates {
                targets.push(ResolvedTarget {
                    function: func,
                    confidence: Confidence::Low,
                    reason: "signature matching",
                });
            }
        }
        
        targets
    }
    
    /// 通过类型签名匹配
    fn match_by_signature(&self, call: &IndirectCall) -> Option<Vec<FunctionName>> {
        // 1. 获取函数指针的类型签名
        let ptr_type = self.type_system.get_type(&call.callee)?;
        let signature = ptr_type.as_func_ptr()?;
        
        // 2. 查找所有匹配签名的函数
        let candidates: Vec<_> = self.type_system
            .all_functions()
            .filter(|f| self.signature_matches(f, &signature))
            .collect();
        
        // 3. 如果候选太多，使用启发式过滤
        if candidates.len() > 10 {
            return self.heuristic_filter(candidates, call);
        }
        
        Some(candidates.into_iter().map(|f| f.name.clone()).collect())
    }
}
```

### 8.3 调用图构建算法

```rust
/// 调用图构建器
pub struct CallGraphBuilder {
    /// 直接调用边
    direct_edges: Vec<CallEdge>,
    /// 间接调用边 (函数指针)
    indirect_edges: Vec<CallEdge>,
    /// 异步调用边
    async_edges: Vec<AsyncEdge>,
}

impl CallGraphBuilder {
    /// 构建完整调用图
    pub fn build(&mut self, project: &Project) -> CallGraph {
        // 1. 收集直接调用
        for file in &project.files {
            for func in &file.functions {
                self.collect_direct_calls(func);
            }
        }
        
        // 2. 解析间接调用
        let resolver = FuncPtrResolver::new(&project);
        for edge in &self.indirect_edges {
            if let Some(targets) = resolver.resolve(&edge.callee) {
                for target in targets {
                    self.direct_edges.push(CallEdge {
                        caller: edge.caller.clone(),
                        callee: target.function,
                        location: edge.location.clone(),
                        call_type: CallType::Indirect {
                            confidence: target.confidence,
                        },
                    });
                }
            }
        }
        
        // 3. 添加异步边
        let async_tracker = AsyncTracker::new(&project);
        for binding in async_tracker.analyze() {
            self.async_edges.push(AsyncEdge {
                trigger_func: binding.trigger_caller,
                handler_func: binding.handler,
                mechanism: binding.mechanism,
                context: binding.context,
            });
        }
        
        // 4. 构建图结构
        CallGraph::from_edges(
            &self.direct_edges,
            &self.async_edges,
        )
    }
}
```

---

## 9. UI/UX 设计

### 9.0 前端架构设计原则

> ⚠️ **核心理念**: 前端架构必须考虑长期扩展性，未来可能支持终端、SSH、调试器等更多功能。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     前端架构设计原则                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. 插件化架构                                                           │
│     ├── 所有面板都是可插拔的插件                                         │
│     ├── 新功能通过插件方式添加                                           │
│     └── 参考 VS Code 的扩展模型                                         │
│                                                                          │
│  2. 灵活的布局系统                                                       │
│     ├── 支持拖拽调整面板位置和大小                                       │
│     ├── 支持多标签、分屏                                                 │
│     ├── 布局状态可保存/恢复                                              │
│     └── 参考 VS Code / JetBrains 的布局                                 │
│                                                                          │
│  3. 统一的通信层                                                         │
│     ├── 前端 ↔ Tauri 后端 (IPC)                                         │
│     ├── 前端 ↔ LSP 服务器 (可选)                                        │
│     └── 前端 ↔ 远程服务器 (SSH, 未来)                                   │
│                                                                          │
│  4. 主题和定制化                                                         │
│     ├── 支持浅色/深色主题                                                │
│     ├── CSS 变量驱动的主题系统                                           │
│     ├── 字体、颜色可配置                                                 │
│     └── 键盘快捷键可配置                                                 │
│                                                                          │
│  5. 国际化 (i18n)                                                        │
│     ├── 首发支持：简体中文 + 英文                                        │
│     ├── react-i18next 方案                                               │
│     ├── 语言包热切换                                                     │
│     └── 社区可贡献翻译                                                   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 前端技术栈选择

| 技术 | 选择 | 理由 |
|------|------|------|
| UI 框架 | **React 18+** | 生态成熟、组件丰富、团队熟悉 |
| 状态管理 | **Zustand** | 轻量、简单、TypeScript 友好 |
| 样式方案 | **Tailwind CSS + CSS Variables** | 快速开发 + 主题支持 |
| 代码编辑器 | **Monaco Editor** | VS Code 同款、功能强大 |
| 图形可视化 | **React Flow** | 专业的流程图库、高性能 |
| 布局系统 | **Allotment** | 可拖拽分割面板 |
| 图标 | **Lucide React** | 美观、体积小 |
| 终端 (未来) | **xterm.js** | 成熟的终端模拟器 |

#### 可扩展架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       FlowSight 前端架构                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                         App Shell (外壳)                           │  │
│  │  ┌─────────┐ ┌─────────────────────────────────┐ ┌─────────────┐  │  │
│  │  │ 菜单栏   │ │           工具栏                │ │   状态栏    │  │  │
│  │  └─────────┘ └─────────────────────────────────┘ └─────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                     Layout Manager (布局管理器)                    │  │
│  │  ┌─────────────┐ ┌─────────────────────────┐ ┌─────────────────┐  │  │
│  │  │  左侧边栏    │ │       主编辑区          │ │     右侧边栏     │  │  │
│  │  │  (可折叠)    │ │     (可分屏/标签)       │ │    (可折叠)      │  │  │
│  │  └─────────────┘ └─────────────────────────┘ └─────────────────┘  │  │
│  │                  ┌─────────────────────────┐                       │  │
│  │                  │       底部面板          │                       │  │
│  │                  │   (可折叠/可拖拽高度)   │                       │  │
│  │                  └─────────────────────────┘                       │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                     Panel Registry (面板注册表)                    │  │
│  │                                                                    │  │
│  │  内置面板:                                                         │  │
│  │  ├── 📁 FileExplorer     文件浏览器                                │  │
│  │  ├── 📝 Editor           代码编辑器 (Monaco)                       │  │
│  │  ├── 🔍 Search           全局搜索                                  │  │
│  │  ├── 📊 FlowView         执行流视图                                │  │
│  │  ├── 🏗️ StructView       结构体关系图                              │  │
│  │  ├── 📋 Outline          代码大纲                                  │  │
│  │  ├── 📜 CallHierarchy    调用层次                                  │  │
│  │  └── ℹ️  Properties      属性面板                                  │  │
│  │                                                                    │  │
│  │  未来扩展 (v2.0+):                                                 │  │
│  │  ├── 💻 Terminal         集成终端 (xterm.js)                       │  │
│  │  ├── 🔗 SSHExplorer      SSH 远程浏览器                            │  │
│  │  ├── 🐛 Debugger         调试器面板                                │  │
│  │  ├── 📡 RemoteIndex      远程索引管理                              │  │
│  │  ├── 🔌 Plugins          插件管理                                  │  │
│  │  └── ⚙️  Settings         设置面板                                  │  │
│  │                                                                    │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                     Service Layer (服务层)                         │  │
│  │                                                                    │  │
│  │  ├── ProjectService      项目管理                                  │  │
│  │  ├── AnalysisService     分析服务 (调用 Tauri 后端)                │  │
│  │  ├── FileService         文件读写                                  │  │
│  │  ├── SearchService       搜索服务                                  │  │
│  │  ├── ThemeService        主题管理                                  │  │
│  │  ├── KeybindingService   快捷键管理                                │  │
│  │  ├── LayoutService       布局持久化                                │  │
│  │  └── (未来) SSHService   SSH 连接管理                              │  │
│  │  └── (未来) TermService  终端管理                                  │  │
│  │                                                                    │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                     IPC Layer (通信层)                             │  │
│  │                                                                    │  │
│  │  ├── TauriIPC            Tauri invoke/listen                       │  │
│  │  ├── (未来) SSHChannel   SSH 通道                                  │  │
│  │  └── (未来) LSPClient    LSP 协议客户端                            │  │
│  │                                                                    │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 面板插件接口设计

```typescript
// 面板插件接口 (未来扩展用)
interface PanelPlugin {
  // 基本信息
  id: string;
  name: string;
  icon: React.ComponentType;
  
  // 面板组件
  component: React.ComponentType<PanelProps>;
  
  // 允许的位置
  allowedPositions: ('left' | 'right' | 'bottom' | 'center')[];
  defaultPosition: 'left' | 'right' | 'bottom' | 'center';
  
  // 生命周期
  onActivate?: () => void;
  onDeactivate?: () => void;
  
  // 快捷键
  keybindings?: Keybinding[];
  
  // 菜单贡献
  menuContributions?: MenuContribution[];
}

// 示例：终端面板 (未来实现)
const TerminalPanel: PanelPlugin = {
  id: 'terminal',
  name: '终端',
  icon: TerminalIcon,
  component: TerminalView,
  allowedPositions: ['bottom', 'center'],
  defaultPosition: 'bottom',
  keybindings: [
    { key: 'ctrl+`', command: 'terminal.toggle' },
    { key: 'ctrl+shift+`', command: 'terminal.new' },
  ],
};
```

#### 主题系统设计

```css
/* CSS 变量驱动的主题系统 */
:root {
  /* 基础色彩 */
  --color-bg-primary: #1e1e1e;
  --color-bg-secondary: #252526;
  --color-bg-tertiary: #2d2d30;
  
  --color-text-primary: #cccccc;
  --color-text-secondary: #9d9d9d;
  --color-text-accent: #569cd6;
  
  /* 边框 */
  --color-border: #3c3c3c;
  
  /* 强调色 */
  --color-accent: #007acc;
  --color-accent-hover: #1c97ea;
  
  /* 语法高亮 */
  --syntax-keyword: #569cd6;
  --syntax-string: #ce9178;
  --syntax-function: #dcdcaa;
  --syntax-type: #4ec9b0;
  --syntax-comment: #6a9955;
  
  /* 异步标记色 (FlowSight 特有) */
  --flow-workqueue: #4fc1ff;
  --flow-timer: #f9c74f;
  --flow-irq: #f94144;
  --flow-callback: #90be6d;
  
  /* 间距 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  
  /* 圆角 */
  --radius-sm: 4px;
  --radius-md: 8px;
}

/* 浅色主题覆盖 */
[data-theme="light"] {
  --color-bg-primary: #ffffff;
  --color-bg-secondary: #f3f3f3;
  --color-text-primary: #333333;
  /* ... */
}
```

#### 未来功能规划

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     功能扩展路线图                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  v1.0 (核心功能)                                                         │
│  ├── ✅ 代码编辑器 (Monaco)                                              │
│  ├── ✅ 文件浏览器                                                       │
│  ├── ✅ 执行流视图                                                       │
│  ├── ✅ 结构体关系图                                                     │
│  ├── ✅ 全局搜索                                                         │
│  └── ✅ 调用层次                                                         │
│                                                                          │
│  v1.5 (体验增强)                                                         │
│  ├── 🔲 集成终端 (xterm.js)                                             │
│  ├── 🔲 键盘快捷键自定义                                                 │
│  ├── 🔲 多主题支持                                                       │
│  └── 🔲 布局保存/恢复                                                    │
│                                                                          │
│  v2.0 (远程支持)                                                         │
│  ├── 🔲 SSH 远程连接                                                     │
│  ├── 🔲 远程文件浏览                                                     │
│  ├── 🔲 远程索引                                                         │
│  └── 🔲 Android 知识库                                                   │
│                                                                          │
│  v3.0 (高级功能)                                                         │
│  ├── 🔲 插件系统                                                         │
│  ├── 🔲 调试器集成                                                       │
│  ├── 🔲 AI 辅助分析                                                      │
│  └── 🔲 协作功能                                                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 9.1 主界面布局

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  📂 File   Edit   View   Analysis   Tools   Help                    ─ □ ✕  │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─────────┐ ┌─────────────────────────────────────────────────┐ ┌─────────┐ │
│ │Explorer │ │  hub.c  ✕ │ usb.c │ core.c │                    │ │Outline  │ │
│ ├─────────┤ ├─────────────────────────────────────────────────┤ ├─────────┤ │
│ │ 📁 linux│ │  1│ #include <linux/usb.h>                      │ │ 📦 hub  │ │
│ │ ├ 📁 drv│ │  2│                                             │ │ ├ probe │ │
│ │ │ ├ hub│ │  3│ static int hub_probe(struct usb_interface   │ │ ├ discon│ │
│ │ │ │   .c│ │  4│                       *intf,                │ │ └ irq   │ │
│ │ │ └ usb│ │  5│                       const struct usb_dev*) │ │         │ │
│ │ └ 📁 cor│ │  6│ {                                           │ │ ─────── │ │
│ │         │ │  7│     struct usb_hub *hub;                    │ │ 📊 Calls│ │
│ │ ─────── │ │  8│     hub = kzalloc(sizeof(*hub), GFP_KERNEL);│ │ kzalloc │ │
│ │ 🔍Search│ │  9│     INIT_WORK(&hub->work, hub_event);       │ │ INIT_WOR│ │
│ │         │ │ 10│     ...                                     │ │ ...     │ │
│ │         │ │ 11│ }                                           │ │         │ │
│ ├─────────┤ ├─────────────────────────────────────────────────┤ │         │ │
│ │FlowView │ │                   执行流视图                     │ │         │ │
│ │ ─────── │ │  ┌──────────────┐      ┌──────────────┐         │ │         │ │
│ │ 🔌 probe│ │  │  hub_probe   │ ──▶  │  kzalloc     │         │ │         │ │
│ │ ⚙️ work │ │  └──────┬───────┘      └──────────────┘         │ │         │ │
│ │ ⚡ irq  │ │         │                                       │ │         │ │
│ │         │ │         ▼ ⚙️                                    │ │         │ │
│ │         │ │  ┌──────────────┐                               │ │         │ │
│ │         │ │  │  hub_event   │  工作队列回调                  │ │         │ │
│ │         │ │  └──────────────┘                               │ │         │ │
│ │         │ │                                                 │ │         │ │
│ └─────────┘ └─────────────────────────────────────────────────┘ └─────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ 📊 Ready │ hub.c │ Line 7, Col 12 │ UTF-8 │ C │ 索引: 完成              │ │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 执行流视图设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  执行流视图 - hub_probe()                           [🔍] [📸] [⚙️] [─][□][✕]│
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔌 usb_driver.probe                                                    │ │
│  │    USB 设备插入且 ID 匹配时调用                                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ 📍 hub_probe()                                              hub.c:42   ││
│  │ ─────────────────────────────────────────────────────────────────────  ││
│  │                                                                         ││
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     ││
│  │  │   kzalloc   │  │usb_alloc_urb│  │ INIT_WORK   │                     ││
│  │  │   内核API   │  │   USB API   │  │  ⚙️ 绑定    │                     ││
│  │  └─────────────┘  └─────────────┘  └──────┬──────┘                     ││
│  │                                           │                             ││
│  │                                    ┌──────▼──────┐                     ││
│  │                                    │  hub_event  │◀─── 异步回调        ││
│  │                                    │ 工作队列执行 │                     ││
│  │                                    │ 📍 hub.c:180│                     ││
│  │                                    └──────┬──────┘                     ││
│  │                                           │                             ││
│  │         ┌─────────────────────────────────┼─────────────────────────┐  ││
│  │         │                                 │                         │  ││
│  │  ┌──────▼──────┐                   ┌──────▼──────┐           ┌──────▼─┐││
│  │  │hub_port_init│                   │hub_port_conn│           │hub_pow │││
│  │  └─────────────┘                   └─────────────┘           └────────┘││
│  │                                                                         ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────── ┐│
│  │ 📋 上下文信息                                                           ││
│  │ ─────────────────────────────────────────────────────────────────────   ││
│  │ 当前节点: hub_event()                                                   ││
│  │ 执行上下文: 进程上下文 (可睡眠)                                          ││
│  │ 触发方式: schedule_work() @ hub.c:58                                    ││
│  │ 调用者: hub_probe() → schedule_work()                                   ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│ 图例: ──▶ 同步调用  ─ ▶ 异步调用  ⚙️ 工作队列  ⏲️ 定时器  ⚡ 中断         │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.3 节点样式

```
普通函数调用:
┌─────────────┐
│  func_name  │  灰色/浅色背景
│  file:line  │
└─────────────┘

内核 API:
┌─────────────┐
│  kzalloc    │  蓝色背景
│  内核 API   │
└─────────────┘

工作队列回调:
┌─────────────┐
│ ⚙️ handler  │  橙色背景
│ 工作队列    │  虚线边框
│ 📍 file:ln  │
└─────────────┘

定时器回调:
┌─────────────┐
│ ⏲️ timer_fn │  紫色背景
│ 定时器回调  │  虚线边框
└─────────────┘

中断处理:
┌─────────────┐
│ ⚡ irq_hand │  红色背景
│ 中断上下文  │  粗边框
└─────────────┘

Tasklet:
┌─────────────┐
│ 🔄 tasklet  │  黄色背景
│ 软中断上下文│
└─────────────┘

回调入口 (ops):
┌───────────────────────┐
│ 🔌 usb_driver.probe   │  绿色背景
│ USB 设备插入时调用     │  双线边框
└───────────────────────┘
```

### 9.4 配色方案

```
Dark Theme (默认):
─────────────────────────
背景:        #1e1e1e
编辑器背景:   #252526
侧边栏:      #333333
高亮:        #264f78
文字:        #d4d4d4
注释:        #6a9955
关键字:      #569cd6
字符串:      #ce9178
函数:        #dcdcaa

节点颜色:
├── 普通:    #3c3c3c
├── 异步:    #4a3a20
├── 中断:    #4a2020
├── API:     #203a4a
└── 入口:    #2a4a2a

Light Theme:
─────────────────────────
背景:        #ffffff
编辑器背景:   #f5f5f5
侧边栏:      #f0f0f0
...
```

### 9.5 国际化 (i18n) 设计

> 🌐 **目标**: FlowSight 面向全球开发者，需要支持多语言界面。

#### 支持优先级

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      语言支持优先级                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   P0 - v1.0 必须支持 (首发语言)                                         │
│   ══════════════════════════════                                         │
│   • 简体中文 (zh-CN) ← 首选默认                                         │
│   • 英文 (en-US)                                                         │
│                                                                          │
│   P1 - v2.0+ 考虑支持 (IDE 功能完善后)                                  │
│   ════════════════════════════════════                                   │
│   • 繁体中文 (zh-TW)                                                     │
│   • 日文 (ja-JP)                                                         │
│   • 韩文 (ko-KR)                                                         │
│                                                                          │
│   P2 - 社区贡献 (开放翻译)                                              │
│   ══════════════════════════                                             │
│   • 法语、德语、西班牙语、俄语等                                         │
│   • 提供翻译模板，欢迎社区 PR                                            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 技术方案

| 组件 | 选择 | 说明 |
|------|------|------|
| i18n 框架 | **react-i18next** | React 生态最成熟的 i18n 方案 |
| 语言检测 | 系统语言 → 用户设置 → 默认 zh-CN | 智能检测，可手动切换 |
| 翻译文件格式 | JSON | 简单、工具链支持好 |
| 插值 | ICU MessageFormat | 支持复数、性别等复杂场景 |

#### 目录结构

```
app/src/i18n/
├── index.ts              # i18n 初始化配置
├── useLocale.ts          # 语言切换 Hook
└── locales/
    ├── zh-CN.json        # 简体中文
    ├── en-US.json        # 英文
    └── _template.json    # 翻译模板 (供贡献者使用)
```

#### 翻译文件示例

```json
// zh-CN.json
{
  "app": {
    "name": "FlowSight",
    "menu": {
      "file": "文件",
      "edit": "编辑",
      "view": "视图",
      "analyze": "分析",
      "help": "帮助"
    },
    "actions": {
      "newProject": "新建项目",
      "openProject": "打开项目",
      "save": "保存",
      "settings": "设置"
    }
  },
  "panels": {
    "explorer": "文件浏览器",
    "outline": "大纲",
    "callHierarchy": "调用层次",
    "flowView": "执行流视图",
    "search": "搜索",
    "properties": "属性"
  },
  "analysis": {
    "analyzing": "正在分析...",
    "complete": "分析完成",
    "error": "分析出错",
    "asyncFlow": "异步执行流",
    "callGraph": "调用关系图",
    "structRelation": "结构体关系"
  },
  "settings": {
    "language": "语言",
    "theme": "主题",
    "darkTheme": "深色主题",
    "lightTheme": "浅色主题"
  }
}
```

```json
// en-US.json
{
  "app": {
    "name": "FlowSight",
    "menu": {
      "file": "File",
      "edit": "Edit",
      "view": "View",
      "analyze": "Analyze",
      "help": "Help"
    },
    "actions": {
      "newProject": "New Project",
      "openProject": "Open Project",
      "save": "Save",
      "settings": "Settings"
    }
  },
  "panels": {
    "explorer": "Explorer",
    "outline": "Outline",
    "callHierarchy": "Call Hierarchy",
    "flowView": "Execution Flow",
    "search": "Search",
    "properties": "Properties"
  },
  "analysis": {
    "analyzing": "Analyzing...",
    "complete": "Analysis Complete",
    "error": "Analysis Error",
    "asyncFlow": "Async Execution Flow",
    "callGraph": "Call Graph",
    "structRelation": "Struct Relations"
  },
  "settings": {
    "language": "Language",
    "theme": "Theme",
    "darkTheme": "Dark Theme",
    "lightTheme": "Light Theme"
  }
}
```

#### 使用方式

```tsx
import { useTranslation } from 'react-i18next';

function MenuBar() {
  const { t } = useTranslation();
  
  return (
    <nav>
      <button>{t('app.menu.file')}</button>
      <button>{t('app.menu.edit')}</button>
      <button>{t('app.menu.view')}</button>
      <button>{t('app.menu.analyze')}</button>
      <button>{t('app.menu.help')}</button>
    </nav>
  );
}
```

#### 语言切换 UI

```
┌──────────────────────────────────────┐
│ ⚙️ 设置                               │
├──────────────────────────────────────┤
│                                      │
│  🌐 语言 / Language                  │
│  ┌────────────────────────────────┐  │
│  │  ● 简体中文                     │  │
│  │  ○ English                     │  │
│  └────────────────────────────────┘  │
│                                      │
│  🎨 主题                             │
│  ┌────────────────────────────────┐  │
│  │  ● 深色                         │  │
│  │  ○ 浅色                         │  │
│  │  ○ 跟随系统                     │  │
│  └────────────────────────────────┘  │
│                                      │
└──────────────────────────────────────┘
```

#### 社区贡献指南

1. **翻译模板**: `_template.json` 包含所有需翻译的 key
2. **贡献流程**: Fork → 添加新语言 JSON → PR
3. **翻译规范**:
   - 保持技术术语一致性
   - 注意 UI 空间限制
   - 使用正式语气

---

## 10. 风险评估与应对

### 10.1 技术风险

| 风险 | 可能性 | 影响 | 应对策略 |
|------|--------|------|----------|
| libclang 集成困难 | 中 | 高 | 先完成 tree-sitter 版本，libclang 作为增强 |
| 大项目性能问题 | 高 | 高 | 增量索引、懒加载、后台处理 |
| 函数指针解析不完整 | 高 | 中 | 置信度评分、允许用户标注 |
| Tauri 跨平台问题 | 低 | 中 | **优先 Windows**，然后 Linux，macOS 跟进 |
| Monaco 定制复杂 | 中 | 低 | 渐进式添加功能 |
| **AIDL 解析复杂** | 中 | 中 | 利用 Android SDK 工具链，渐进式支持 |
| **JNI 动态注册难追踪** | 高 | 中 | 知识库 + 启发式匹配，标注不确定性 |
| **AOSP 代码量巨大** | 高 | 高 | 按模块索引，支持部分加载 |
| **Kotlin 协程复杂** | 中 | 中 | 参考 kotlinx.coroutines 设计，重点支持常见模式 |

### 10.2 项目风险

| 风险 | 可能性 | 影响 | 应对策略 |
|------|--------|------|----------|
| 开发周期超预期 | 高 | 中 | 敏捷开发，MVP 优先 |
| 需求变更 | 中 | 中 | 模块化设计，易于调整 |
| 团队资源不足 | 中 | 高 | 核心功能优先，逐步扩展 |

### 10.3 风险缓解矩阵

```
              影响
         低    中    高
       ┌─────┬─────┬─────┐
   高  │ 监控│ 重点│ 紧急│  可
       │     │ 关注│ 处理│  能
       ├─────┼─────┼─────┤  性
   中  │ 接受│ 监控│ 重点│
       │     │     │ 关注│
       ├─────┼─────┼─────┤
   低  │ 忽略│ 接受│ 监控│
       │     │     │     │
       └─────┴─────┴─────┘
```

---

## 11. 资源估算

### 11.1 人力资源

```
角色                  人数    Phase 0-1   Phase 2-3   Phase 4    Phase 5(Android)
───────────────────────────────────────────────────────────────────────────────
核心开发 (Rust)        1-2     100%        80%         60%        70%
前端开发 (React)       1       50%         100%        80%        60%
Android/Java 开发      0-1     0%          0%          20%        100%
UI/UX 设计             0.5     50%         50%         30%        40%
测试/QA                0.5     20%         50%         80%        80%
文档/技术写作          0.5     20%         30%         50%        60%
───────────────────────────────────────────────────────────────────────────────
总计 (全职当量)        2-4     2.4         3.1         3.2        4.1
```

### 11.2 技术资源

```
开发环境:
├── 开发机: Linux/Mac 工作站 (推荐 32GB RAM)
├── 测试机: Windows/Linux VM
├── CI/CD: GitHub Actions
└── 存储: GitHub (代码) + 对象存储 (发布包)

测试资源:
├── Linux 内核源码 (测试大项目)
├── 各种驱动代码样本
├── AOSP 源码 (Android 测试)
├── Android 示例项目
└── 自动化测试基础设施
```

### 11.3 时间资源

```
总开发周期: 约 18 个月

Phase 0: 2 个月  (技术验证)
Phase 1: 3 个月  (核心引擎)
Phase 2: 3 个月  (IDE 基础)
Phase 3: 3 个月  (完善优化)
Phase 4: 3 个月  (高级功能) → v1.0 发布
Phase 5: 4 个月  (Android 支持) → v2.0 发布
```

---

## 12. 成功指标

### 12.1 技术指标

| 指标 | 目标值 | 备注 |
|------|--------|------|
| Linux 内核索引时间 | < 10 分钟 | 首次索引 |
| 增量更新时间 | < 5 秒 | 单文件修改 |
| 符号搜索延迟 | < 50ms | P99 |
| UI 响应延迟 | < 100ms | P99 |
| 内存占用 | < 4GB | 内核项目 |
| 安装包大小 | < 50MB | 压缩后 |
| 异步模式覆盖 | > 90% | 常见模式 |
| 函数指针解析率 | > 80% | 有确定结果 |

### 12.2 用户指标

| 指标 | 目标值 (v1.0) | 备注 |
|------|---------------|------|
| 下载量 | > 10,000 | 首年 |
| 活跃用户 | > 1,000 | 月活 |
| GitHub Stars | > 500 | |
| 用户满意度 | > 4.0/5.0 | |

### 12.3 质量指标

| 指标 | 目标值 | 备注 |
|------|--------|------|
| 测试覆盖率 | > 70% | 单元测试 |
| 崩溃率 | < 0.1% | |
| Bug 修复时间 | < 7 天 | P1 |
| 文档完整度 | > 80% | |

---

## 附录 A: 异步模式库 (初始版本)

```yaml
# async_patterns.yaml

work_struct:
  description: "工作队列"
  context: "进程上下文，可睡眠"
  bind:
    - pattern: 'INIT_WORK\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,\s*(?P<handler>\w+)\s*\)'
    - pattern: 'INIT_WORK_ONSTACK\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,\s*(?P<handler>\w+)\s*\)'
  trigger:
    - pattern: 'schedule_work\s*\(\s*&?(?P<var>[\w\.\->]+)\s*\)'
    - pattern: 'queue_work\s*\([^,]+,\s*&?(?P<var>[\w\.\->]+)\s*\)'
    - pattern: 'queue_work_on\s*\([^,]+,\s*[^,]+,\s*&?(?P<var>[\w\.\->]+)\s*\)'

delayed_work:
  description: "延迟工作队列"
  context: "进程上下文，可睡眠"
  bind:
    - pattern: 'INIT_DELAYED_WORK\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,\s*(?P<handler>\w+)\s*\)'
  trigger:
    - pattern: 'schedule_delayed_work\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,'
    - pattern: 'queue_delayed_work\s*\([^,]+,\s*&?(?P<var>[\w\.\->]+)\s*,'
    - pattern: 'mod_delayed_work\s*\([^,]+,\s*&?(?P<var>[\w\.\->]+)\s*,'

timer_list:
  description: "内核定时器"
  context: "软中断上下文，不可睡眠"
  bind:
    - pattern: 'timer_setup\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,\s*(?P<handler>\w+)\s*,'
    - pattern: 'DEFINE_TIMER\s*\(\s*(?P<var>\w+)\s*,\s*(?P<handler>\w+)\s*\)'
  trigger:
    - pattern: 'mod_timer\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,'
    - pattern: 'add_timer\s*\(\s*&?(?P<var>[\w\.\->]+)\s*\)'

hrtimer:
  description: "高精度定时器"
  context: "硬中断上下文"
  bind:
    - pattern: '(?P<var>[\w\.\->]+)\.function\s*=\s*(?P<handler>\w+)'
  trigger:
    - pattern: 'hrtimer_start\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,'

tasklet:
  description: "Tasklet"
  context: "软中断上下文，不可睡眠"
  bind:
    - pattern: 'tasklet_init\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,\s*(?P<handler>\w+)\s*,'
    - pattern: 'DECLARE_TASKLET\s*\(\s*(?P<var>\w+)\s*,\s*(?P<handler>\w+)\s*\)'
    - pattern: 'DECLARE_TASKLET_DISABLED\s*\(\s*(?P<var>\w+)\s*,\s*(?P<handler>\w+)\s*\)'
  trigger:
    - pattern: 'tasklet_schedule\s*\(\s*&?(?P<var>[\w\.\->]+)\s*\)'
    - pattern: 'tasklet_hi_schedule\s*\(\s*&?(?P<var>[\w\.\->]+)\s*\)'

irq:
  description: "硬中断处理"
  context: "中断上下文，不可睡眠"
  bind:
    - pattern: 'request_irq\s*\([^,]+,\s*(?P<handler>\w+)\s*,'
    - pattern: 'devm_request_irq\s*\([^,]+,\s*[^,]+,\s*(?P<handler>\w+)\s*,'
  trigger:
    - type: "hardware"
      description: "硬件中断触发"

threaded_irq:
  description: "线程化中断"
  context: "进程上下文，可睡眠"
  bind:
    - pattern: 'request_threaded_irq\s*\([^,]+,\s*(?P<top_half>\w+)\s*,\s*(?P<handler>\w+)\s*,'
    - pattern: 'devm_request_threaded_irq\s*\([^,]+,\s*[^,]+,\s*(?P<top_half>\w+)\s*,\s*(?P<handler>\w+)\s*,'
  trigger:
    - type: "hardware"
      description: "硬件中断触发后，由内核线程执行"

kthread:
  description: "内核线程"
  context: "进程上下文，可睡眠"
  bind:
    - pattern: 'kthread_run\s*\(\s*(?P<handler>\w+)\s*,'
    - pattern: 'kthread_create\s*\(\s*(?P<handler>\w+)\s*,'
  trigger:
    - pattern: 'wake_up_process\s*\('

rcu_callback:
  description: "RCU 回调"
  context: "软中断上下文"
  bind:
    - pattern: 'call_rcu\s*\(\s*&?(?P<var>[\w\.\->]+)\s*,\s*(?P<handler>\w+)\s*\)'
    - pattern: 'call_srcu\s*\([^,]+,\s*&?(?P<var>[\w\.\->]+)\s*,\s*(?P<handler>\w+)\s*\)'
  trigger:
    - type: "grace_period"
      description: "RCU 宽限期结束后执行"

notifier:
  description: "通知链"
  context: "取决于通知链类型"
  bind:
    - pattern: '(?P<var>[\w\.\->]+)\.notifier_call\s*=\s*(?P<handler>\w+)'
  trigger:
    - pattern: 'blocking_notifier_call_chain\s*\('
    - pattern: 'atomic_notifier_call_chain\s*\('
    - pattern: 'raw_notifier_call_chain\s*\('
```

---

## 附录 B: 知识库支持路线图

知识库按以下优先级顺序构建：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     知识库构建优先级路线图                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   第一优先级 (P0): Linux 内核                                           │
│   ════════════════════════════════                                       │
│   v0.1 → 基础异步模式 (work_struct, timer, irq, tasklet)                │
│   v0.2 → 常用驱动框架 (USB, char_dev, platform, I2C)                    │
│   v0.3 → 内核核心机制 (RCU, kthread, completion, notifier)              │
│   v0.5 → 网络子系统 (netdev, socket, nf_hook)                           │
│   v0.6 → 文件系统 (VFS, block, buffer)                                  │
│   v1.0 → Linux 内核完整支持 ✓                                           │
│                                                                          │
│   第二优先级 (P1): Android 系统                                         │
│   ════════════════════════════════                                       │
│   v1.1 → App 层 (Activity, Handler, Coroutine, LiveData)                │
│   v1.2 → Binder IPC + AIDL                                              │
│   v1.3 → JNI 跨语言桥接                                                 │
│   v1.5 → Framework 层 (AMS, WMS, PMS)                                   │
│   v1.6 → HAL 层 (HIDL, AIDL HAL)                                        │
│   v2.0 → Android 系统完整支持 ✓                                         │
│                                                                          │
│   第三优先级 (P2): 其他语言和平台                                       │
│   ════════════════════════════════                                       │
│   v2.1 → C++ (std::async, std::thread, callback patterns)               │
│   v2.2 → Rust (tokio, async-std, crossbeam)                             │
│   v2.3 → Go (goroutine, channel, select)                                │
│   v2.4 → Java 通用 (ExecutorService, CompletableFuture)                 │
│   v2.5 → 嵌入式 RTOS (FreeRTOS, Zephyr)                                 │
│   v3.0 → 多语言多平台完整支持 ✓                                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 详细知识库清单

#### P0: Linux 内核知识库

| 分类 | 知识库文件 | 包含内容 | 优先级 |
|------|-----------|---------|--------|
| **核心机制** | `platforms/linux-kernel/core/` | | |
| | workqueue.yaml | work_struct, delayed_work | P0.1 ✅ |
| | timer.yaml | timer_list, hrtimer | P0.1 |
| | irq.yaml | request_irq, threaded_irq | P0.1 |
| | tasklet.yaml | tasklet_struct | P0.1 |
| | rcu.yaml | call_rcu, rcu_read_lock | P0.3 |
| | kthread.yaml | kthread_run, kthread_worker | P0.3 |
| | completion.yaml | wait_for_completion | P0.3 |
| | notifier.yaml | notifier_chain | P0.3 |
| **驱动框架** | `platforms/linux-kernel/drivers/` | | |
| | usb.yaml | usb_driver, urb | P0.2 ✅ |
| | char_dev.yaml | file_operations | P0.2 ✅ |
| | platform.yaml | platform_driver | P0.2 |
| | pci.yaml | pci_driver | P0.2 |
| | i2c.yaml | i2c_driver | P0.2 |
| | spi.yaml | spi_driver | P0.2 |
| | gpio.yaml | gpio_chip | P0.2 |
| **网络子系统** | `platforms/linux-kernel/net/` | | |
| | netdev.yaml | net_device_ops | P0.5 |
| | socket.yaml | proto_ops | P0.5 |
| | netfilter.yaml | nf_hook_ops | P0.5 |
| **文件系统** | `platforms/linux-kernel/fs/` | | |
| | vfs.yaml | file_operations, inode_ops | P0.6 |
| | block.yaml | block_device_operations | P0.6 |

#### P1: Android 知识库

| 分类 | 知识库文件 | 包含内容 | 优先级 |
|------|-----------|---------|--------|
| **App 层** | `platforms/android/app/` | | |
| | activity.yaml | Activity/Fragment lifecycle | P1.1 ✅ |
| | android_async.yaml | Handler, Executor, WorkManager | P1.1 ✅ |
| | jetpack.yaml | LiveData, ViewModel, Room | P1.1 |
| **Framework 层** | `platforms/android/framework/` | | |
| | binder.yaml | AIDL, Binder, ServiceManager | P1.2 ✅ |
| | ams.yaml | ActivityManagerService | P1.5 |
| | wms.yaml | WindowManagerService | P1.5 |
| | pms.yaml | PackageManagerService | P1.5 |
| **HAL 层** | `platforms/android/hal/` | | |
| | hidl.yaml | HIDL interfaces | P1.6 |
| | aidl_hal.yaml | AIDL HAL (Android 11+) | P1.6 |
| **跨语言** | `bridges/` | | |
| | jni.yaml | Java ↔ C/C++ | P1.3 ✅ |

#### P2: 其他语言知识库

| 分类 | 知识库文件 | 包含内容 | 优先级 |
|------|-----------|---------|--------|
| **语言** | `languages/` | | |
| | c/async_patterns.yaml | C 异步模式 | P0.1 ✅ |
| | kotlin/coroutines.yaml | Kotlin 协程 | P1.1 ✅ |
| | cpp/async_patterns.yaml | C++ 异步模式 | P2.1 |
| | rust/async_patterns.yaml | Rust async | P2.2 |
| | go/async_patterns.yaml | Go 并发 | P2.3 |
| | java/async_patterns.yaml | Java 并发 | P2.4 |

---

## 附录 C: 框架知识库示例 (USB)

```yaml
# frameworks/usb.yaml

usb_driver:
  description: "USB 设备驱动框架"
  header: "linux/usb.h"
  registration:
    - function: "usb_register"
    - function: "module_usb_driver"
  
  callbacks:
    probe:
      description: "设备探测回调"
      trigger: "USB 设备插入且 ID 匹配"
      context: "进程上下文"
      signature: "int (*)(struct usb_interface *, const struct usb_device_id *)"
      return_value:
        success: "0"
        failure: "负数错误码"
      typical_actions:
        - "分配设备私有数据"
        - "初始化设备"
        - "注册字符设备/网络设备等"
    
    disconnect:
      description: "设备断开回调"
      trigger: "USB 设备拔出或驱动卸载"
      context: "进程上下文"
      signature: "void (*)(struct usb_interface *)"
      typical_actions:
        - "停止 I/O"
        - "释放资源"
        - "注销子设备"
    
    suspend:
      description: "设备挂起回调"
      trigger: "系统休眠或 USB 自动挂起"
      context: "进程上下文"
      signature: "int (*)(struct usb_interface *, pm_message_t)"
    
    resume:
      description: "设备恢复回调"
      trigger: "系统唤醒或 USB 恢复"
      context: "进程上下文"
      signature: "int (*)(struct usb_interface *)"

file_operations:
  description: "字符设备文件操作"
  header: "linux/fs.h"
  
  callbacks:
    open:
      description: "设备打开"
      trigger: "用户空间 open() 系统调用"
      context: "进程上下文"
    
    release:
      description: "设备关闭"
      trigger: "用户空间 close() 且引用计数归零"
      context: "进程上下文"
    
    read:
      description: "设备读取"
      trigger: "用户空间 read() 系统调用"
      context: "进程上下文"
    
    write:
      description: "设备写入"
      trigger: "用户空间 write() 系统调用"
      context: "进程上下文"
    
    unlocked_ioctl:
      description: "设备控制"
      trigger: "用户空间 ioctl() 系统调用"
      context: "进程上下文"
```

---

## 附录 D: 开发环境设置

### Windows (首要开发平台)

```powershell
# Windows 开发环境设置

# 1. 安装 Rust (使用 rustup-init.exe)
# 下载: https://rustup.rs/
# 或使用 winget:
winget install Rustlang.Rustup
rustup default stable

# 2. 安装 Node.js
winget install OpenJS.NodeJS.LTS
npm install -g pnpm

# 3. 安装 Visual Studio Build Tools (C++ 编译器)
winget install Microsoft.VisualStudio.2022.BuildTools
# 安装时选择 "Desktop development with C++"

# 4. 安装 LLVM (用于 libclang)
winget install LLVM.LLVM
# 添加到 PATH: C:\Program Files\LLVM\bin
# 设置环境变量: LIBCLANG_PATH=C:\Program Files\LLVM\bin

# 5. 安装 WebView2 (Tauri 依赖，Windows 10/11 通常已预装)
# 如未安装: https://developer.microsoft.com/microsoft-edge/webview2/

# 6. 克隆项目
git clone https://github.com/TbusOS/flowsight.git
cd flowsight

# 7. 安装依赖
pnpm install
cargo build

# 8. 运行开发版
cargo tauri dev
```

### Linux

```bash
# Linux (Ubuntu/Debian) 开发环境设置

# 1. 安装 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup default stable

# 2. 安装 Node.js (使用 nvm)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 20
npm install -g pnpm

# 3. 安装 Tauri 依赖
sudo apt update
sudo apt install -y libwebkit2gtk-4.1-dev build-essential curl wget \
    libssl-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev

# 4. 安装 LLVM/Clang (用于 libclang)
sudo apt install -y llvm-dev libclang-dev clang

# 5. 克隆项目并构建
git clone https://github.com/TbusOS/flowsight.git
cd flowsight
pnpm install
cargo build
cargo tauri dev
```

### macOS

```bash
# macOS 开发环境设置

# 1. 安装 Homebrew (如未安装)
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# 2. 安装 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup default stable

# 3. 安装 Node.js
brew install node
npm install -g pnpm

# 4. 安装 Xcode Command Line Tools
xcode-select --install

# 5. 安装 LLVM (用于 libclang)
brew install llvm
echo 'export LIBCLANG_PATH=$(brew --prefix llvm)/lib' >> ~/.zshrc

# 6. 克隆项目并构建
git clone https://github.com/TbusOS/flowsight.git
cd flowsight
pnpm install
cargo build
cargo tauri dev
```

---

*文档版本: 1.0*  
*创建日期: 2026-01*  
*作者: FlowSight Team*


