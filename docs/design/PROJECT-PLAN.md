# 🔭 FlowSight 项目规划书

> **下一代跨平台代码编辑器 IDE**
> 
> 让你看到代码的"灵魂"——执行流、异步调用、数据结构关系
> 
> 🎯 **愿景**：成为全球开发者最喜爱的代码阅读和编辑工具
> 
> ⭐ **核心差异**：完整代码编辑 + 实时执行流可视化 + AI 代码理解
> 
> 📍 **首发支持**：Linux 内核 → Android → 更多平台

---

## 📋 目录

1. [项目愿景](#1-项目愿景)
2. [核心价值主张](#2-核心价值主张)
3. [技术架构设计](#3-技术架构设计)
4. [技术选型](#4-技术选型)
5. [详细开发计划](#5-详细开发计划)
   - [5.2 Phase 0: 原型验证](#52-phase-0-原型验证-8-周)
   - [5.3 Phase 1: 核心引擎增强](#53-phase-1-核心引擎增强-12-周) ⭐ 关键
   - [5.4 Phase 2: IDE 交互体验](#54-phase-2-ide-交互体验-12-周)
   - [5.5 Phase 3: Trace 集成](#55-phase-3-完善与-trace-集成-12-周)
   - [5.6 Phase 4: AI 集成](#56-phase-4-ai-集成-8-周) ⭐ 新增
   - [5.7 Phase 5: 质量保证与发布](#57-phase-5-质量保证与发布-12-周)
6. [里程碑定义](#6-里程碑定义)
7. [项目结构](#7-项目结构)
8. [核心算法设计](#8-核心算法设计)
9. [UI/UX 设计](#9-uiux-设计)
10. [架构改进详细设计](#10-架构改进详细设计) ⭐ 新增
    - [10.1 增量解析架构](#101-增量解析架构)
    - [10.2 大型项目内存管理](#102-大型项目内存管理)
    - [10.3 进度报告系统](#103-进度报告系统)
    - [10.4 智能折叠算法](#104-智能折叠算法)
    - [10.5 新增 flowsight-trace](#105-新增-crate-flowsight-trace)
    - [10.6 场景描述语言设计](#106-场景描述语言设计-flowsight-scenario-language) ⭐ 新增
    - [10.7 新增 flowsight-symbolic](#107-新增-crate-flowsight-symbolic) ⭐⭐ 核心
11. [风险评估与应对](#11-风险评估与应对-更新)
12. [资源估算](#12-资源估算)
13. [成功指标](#13-成功指标) ⭐ 新增
14. [扩展性设计](#14-扩展性设计) ⭐ 新增
    - [14.4 AI 集成设计](#144-ai-集成设计-v15) ⭐ 重要

---

## 🎯 核心开发策略

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         开发策略：先落地，再扩展                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   第一阶段：IDE 落地 (v1.0)                                              │
│   ══════════════════════════                                             │
│   • 知识库：只支持 Linux 内核                                            │
│   • 平台：Windows 优先 → Linux → macOS                                  │
│   • 语言：简体中文 + 英文 (首发双语支持)                                 │
│   • 目标：把 IDE 完整落地、调试稳定、发布正式版                          │
│                                                                          │
│   第二阶段：知识扩展 (v2.0+)                                             │
│   ══════════════════════════                                             │
│   • IDE 稳定后，逐步添加 Android 知识库                                  │
│   • 再逐步添加其他语言和平台                                             │
│   • 稳扎稳打，每步充分测试                                               │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  v0.1 → v0.5 → v1.0          v1.5 → v2.0          v2.5 → v3.0   │   │
│   │   │       │       │            │       │            │       │    │   │
│   │   └───────┴───────┘            └───────┘            └───────┘    │   │
│   │    Linux 内核 + IDE             Android              其他        │   │
│   │    ════════════════             ════════             ════        │   │
│   │     当前阶段重点                 下一阶段             远期        │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 1. 项目愿景

### 1.1 问题陈述

当开发者面对 Linux 内核这样的超大型代码库（2000万+ 行）时，现有工具存在严重不足：

| 现有工具 | 能做什么 | 做不到什么 |
|----------|----------|------------|
| VS Code + clangd | 符号跳转、补全 | 看不到异步执行流、函数指针指向 |
| Source Insight | 符号索引、调用图 | 不理解内核异步机制 |
| Understand | 静态分析、度量 | 无法追踪回调绑定 |
| Sourcetrail | 可视化调用图 | 已停止维护，不理解语义 |

**核心痛点**：当代码出现以下模式时，所有 IDE 都"迷路"了：

```c
// 😵 现有 IDE 看到这里就断了
INIT_WORK(&dev->work, my_handler);    // 绑定
schedule_work(&dev->work);             // 触发 → ??? 谁被调用？

request_irq(irq, irq_handler, ...);    // 注册 → ??? 何时执行？

static struct file_operations fops = {
    .read = my_read,                    // 赋值 → ??? 谁调用 .read？
};
```

### 1.2 解决方案

**FlowSight** —— 一个能"看懂"代码执行流的 IDE：

- 🔍 **静态分析** = 不需要运行代码，纯代码阅读
- 🧠 **语义理解** = 理解异步机制、回调模式、函数指针
- 📊 **可视化** = 看到完整的执行流程图
- ⏱️ **动态结合** = 允许导入运行时 Trace 数据进行验证
- 🖥️ **跨平台** = Windows (首要) / Linux / macOS

### 1.3 目标用户

| 用户群体 | 使用场景 |
|----------|----------|
| Linux 内核开发者 | 理解子系统、审查补丁 |
| 驱动开发者 | 学习驱动框架、调试问题 |
| **Android 系统开发者** | 理解 Framework、追踪 Binder 调用 |
| **Android App 开发者** | 分析复杂的回调和协程流程 |
| 安全研究员 | 漏洞分析、攻击面评估 |
| 嵌入式开发者 | 理解 BSP、定制内核 |
| 学生/教育者 | 学习操作系统原理 |

---

## 2. 核心价值主张

### 2.1 差异化功能

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      FlowSight 核心功能矩阵                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   功能                          VS Code    Source Insight   FlowSight       │
│   ─────────────────────────────────────────────────────────────────────────  │
│   基础代码编辑                    ✅           ✅              ✅            │
│   符号跳转 (LSP)                  ✅           ✅              ✅            │
│   函数调用图                      ⚠️           ✅              ✅ (交互式)   │
│   ─────────────────────────────────────────────────────────────────────────  │
│   ⭐ 场景化数据流分析              ❌           ❌              ✅ 核心      │
│   ⭐ 指定参数看变量值              ❌           ❌              ✅ 核心      │
│   ⭐ 实时高亮执行路径              ❌           ❌              ✅ 核心      │
│   ─────────────────────────────────────────────────────────────────────────  │
│   异步执行流可视化                ❌           ❌              ✅ 核心       │
│   函数指针解析                    ❌           ⚠️              ✅ 核心       │
│   运行时 Trace 导入               ❌           ❌              ✅ 独有       │
│   Kconfig/DTS 解析                ❌           ❌              ✅ 独有       │
│   ─────────────────────────────────────────────────────────────────────────  │
│   内核框架知识库                  ❌           ❌              ✅            │
│   智能文档生成                    ❌           ❌              ✅            │
│   数据结构生命周期                ❌           ❌              ✅            │
│   ─────────────────────────────────────────────────────────────────────────  │
│   AI 代码理解                     ❌           ❌              ✅ v1.5       │
│   Android Binder 追踪             ❌           ❌              ✅ v2.0       │
│   JNI 跨语言分析                  ❌           ❌              ✅ v2.0       │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心竞争力：场景化数据流分析

> **不运行代码，就能看到代码在特定输入下的行为**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      场景化数据流分析示例                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   用户操作:                                                                  │
│   1. 打开 usb_probe() 函数                                                  │
│   2. 右键 → "创建分析场景"                                                  │
│   3. 填写: id->idVendor = 0x1234, id->idProduct = 0x5678                   │
│   4. 点击 "分析"                                                            │
│                                                                              │
│   FlowSight 显示:                                                           │
│   ┌──────────────────────────────────────────────────────────────────────┐  │
│   │  执行流图                                   │  代码编辑器             │  │
│   │                                             │                        │  │
│   │  ┌─────────────────┐                       │  58 │ usb_probe(...)   │  │
│   │  │ usb_probe()     │                       │     │ // idVendor=0x1234│  │
│   │  │ idVendor=0x1234 │                       │  60 │ dev->type = ...   │  │
│   │  └────────┬────────┘                       │     │ // type = 0x56   │  │
│   │           ▼                                │  62 │ if (type == 0x56) │  │
│   │  ┌─────────────────┐                       │     │ // ✅ 条件满足    │  │
│   │  │ dev->type=0x56  │                       │  63 │   init_type_a()   │  │
│   │  └────────┬────────┘                       │     │ // ← 将执行       │  │
│   │      ┌────┴────┐                           │  64 │ else              │  │
│   │      ▼         ▼                           │     │ // ❌ 不执行      │  │
│   │  ┌───────┐ ┌───────┐                       │  65 │   init_type_b()   │  │
│   │  │✅ A   │ │❌ B   │                       │     │ // (灰显)         │  │
│   │  └───────┘ └───────┘                       │                        │  │
│   └──────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│   价值: 不用调试器，就能看到代码在特定输入下的完整行为！                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 用户故事

**故事1：理解 USB 热插拔流程**

> 作为内核开发者，我想看到当 USB 设备插入时，从 hub_irq() 中断到我的驱动 probe() 
> 被调用的完整流程，包括中间经过的工作队列、tasklet。我希望能在图上折叠掉我不关心的内核锁机制代码。

**故事2：追踪内存分配**

> 作为安全研究员，我想看到 kmalloc() 分配的内存在哪些函数中被使用，
> 最终在哪里被释放，并且我导入了一份 ftrace 日志，想在代码中高亮显示实际执行过的路径。

**故事3：编写新驱动**

> 作为驱动开发者，我写完了一个 I2C 驱动，想一键生成一份包含调用流程图和结构体关系图的 Markdown 文档，
> 以便向团队汇报。

---

## 3. 技术架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                             FlowSight                                        │
│                              整体架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           表现层 (Presentation)                         │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │                      Tauri 桌面应用                              │   │ │
│  │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐       │   │ │
│  │  │  │  编辑器   │ │  项目    │ │  流程图   │ │  知识库   │       │   │ │
│  │  │  │  Monaco   │ │  管理器  │ │  D3/React │ │  编辑器   │       │   │ │
│  │  │  └───────────┘ └───────────┘ └───────────┘ └───────────┘       │   │ │
│  │  │                      React + TypeScript                         │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     │ Tauri IPC / Commands                   │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           应用层 (Application)                          │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │ │
│  │  │   项目      │ │   查询     │ │   LSP     │ │   配置      │      │ │
│  │  │   服务      │ │   服务     │ │   客户端    │ │   管理      │      │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘      │ │
│  │                           Rust (Tauri Backend)                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           核心层 (Core)                                 │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐ │ │
│  │  │                       分析引擎 (flowsight-core)                         │ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    │ │ │
│  │  │  │ 解析器  │ │ 索引器  │ │ 类型    │ │ 调用图  │ │ 异步    │    │ │ │
│  │  │  │ Parser  │ │ Indexer │ │ System  │ │ Builder │ │ Tracker │    │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘    │ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐                │ │ │
│  │  │  │ 函数    │ │ Kconfig │ │ 知识库  │ │ Trace   │                │ │ │
│  │  │  │ 指针    │ │ /DTS    │ │ 引擎    │ │ Importer│                │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘                │ │ │
│  │  └───────────────────────────────────────────────────────────────────┘ │ │
│  │                              Rust                                       │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                          基础层 (Infrastructure)                        │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │ │
│  │  │ tree-sitter │ │  LSP/Clang  │ │   SQLite    │ │   sled      │      │ │
│  │  │ (快速解析)  │ │ (精确语义)  │ │  (符号表)   │ │  (调用图)   │      │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘      │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 核心模块设计增强

#### 3.2.1 混合解析引擎 (Hybrid Parser)

*   **Tree-sitter**: 负责快速的语法高亮、大纲提取和初步的模式匹配。
*   **LSP 集成 (clangd)**: 负责精确的"跳转到定义"、"查找引用"、宏展开。我们不重复造轮子，而是利用成熟的 LSP 生态。
*   **Kconfig/DTS 解析**: 专门的模块解析内核配置文件 `.config` 和设备树 `.dts`，用于剔除未编译代码和关联硬件信息。

#### 3.2.2 动态 Trace 集成

*   **Importer**: 支持导入 `ftrace` (text/binary), `systrace`, `perf.data` 等格式。
*   **Mapper**: 将 Trace 中的函数地址/符号映射回源码位置。
*   **Visualizer**: 在静态调用图上叠加"热力图"或高亮路径，显示实际执行流。

#### 3.2.3 知识库编辑器

*   **GUI Editor**: 内置工具，允许用户通过 UI 操作创建新的匹配规则。
    *   例如：选中代码 -> 右键 "标记为异步触发点" -> 填写参数 -> 生成 YAML。

---

## 4. 技术选型

### 4.1 技术栈总览

| 层次 | 技术 | 理由 |
|------|------|------|
| **桌面框架** | Tauri 2.0 | 高性能、小体积、Rust 后端 |
| **前端框架** | React 18 + TS | 生态成熟、组件丰富 |
| **代码编辑器** | Monaco Editor | VS Code 同款，功能完整 |
| **LSP 客户端** | monaco-languageclient | 连接 clangd/rust-analyzer |
| **执行流可视化** | React Flow | 交互式图谱，开发效率高 |
| **终端** | xterm.js | 成熟的 Web 终端实现 |
| **核心引擎** | Rust | 内存安全、高性能 |
| **解析** | tree-sitter + clangd | 速度与精度的平衡 |
| **存储** | SQLite + sled | 关系型与图数据的结合 |
| **AI 后端** | Ollama / OpenAI API | 本地+云端双支持 |

### 4.2 为什么我们能做好完整 IDE？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FlowSight IDE 技术优势                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   不需要从零开始！我们站在巨人肩膀上：                                       │
│                                                                              │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐               │
│   │ Monaco Editor  │  │ clangd LSP     │  │ React Flow     │               │
│   │ (VS Code 核心) │  │ (智能补全)     │  │ (交互式图谱)   │               │
│   │                │  │                │  │                │               │
│   │ • 代码编辑     │  │ • 自动补全     │  │ • 拖拽缩放     │               │
│   │ • 语法高亮     │  │ • 跳转定义     │  │ • 节点连线     │               │
│   │ • 多光标       │  │ • 错误诊断     │  │ • 布局算法     │               │
│   │ • Code Lens    │  │ • 悬停文档     │  │ • 自定义节点   │               │
│   └────────────────┘  └────────────────┘  └────────────────┘               │
│           │                  │                  │                           │
│           └──────────────────┼──────────────────┘                           │
│                              ▼                                               │
│   ┌──────────────────────────────────────────────────────────────────────┐  │
│   │                      FlowSight 核心引擎                               │  │
│   │                                                                       │  │
│   │   我们只需要专注于：                                                  │  │
│   │   ⭐ 异步执行流分析                                                   │  │
│   │   ⭐ 函数指针解析                                                     │  │
│   │   ⭐ 知识库驱动的模式识别                                             │  │
│   │   ⭐ 实时增量分析                                                     │  │
│   │   ⭐ AI 代码理解                                                      │  │
│   │                                                                       │  │
│   └──────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. 详细开发计划

### 5.1 总体时间线

```
2026                                              2027
Q1        Q2        Q3        Q4        Q1        Q2        Q3
│         │         │         │         │         │         │
▼         ▼         ▼         ▼         ▼         ▼         ▼
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│  P0     │   P1    │   P2    │   P3    │   P4    │   P5    │   P6    │
│ 原型    │  核心   │  IDE    │  Trace  │  AI     │  测试   │  生态   │
│ 验证    │  引擎   │  交互   │  集成   │  集成   │  发布   │  建设   │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
   MVP       Alpha     Beta              RC        v1.0      v1.5+
                                                  (稳定版)  (AI版)
```

### 5.1.1 📍 当前状态总览 (2026-01-07 凌晨更新)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          📊 开发进度总览                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Phase 0: 原型验证          [██████████████████░░] 90%  ✅ 基本完成        │
│   ├─ 核心功能                [████████████████████] 100% ✅                  │
│   └─ 测试框架                [░░░░░░░░░░░░░░░░░░░░] 0%   🔜 延后            │
│                                                                              │
│   Phase 1: 核心引擎          [████████░░░░░░░░░░░░] 40%  🔄 进行中          │
│   ├─ 增量解析                [██████░░░░░░░░░░░░░░] 30%                      │
│   ├─ 异步追踪                [████████████████████] 100% ✅                  │
│   └─ 函数指针解析            [████████████████████] 100% ✅                  │
│                                                                              │
│   Phase 2: IDE 交互          [██████████████████░░] 90%  🔄 进行中          │
│   ├─ Monaco 编辑器           [████████████████████] 100% ✅                  │
│   ├─ 目录树浏览              [████████████████████] 100% ✅                  │
│   ├─ 执行流可视化            [████████████████████] 100% ✅                  │
│   ├─ UI/UX 改进 (短期)       [████████████████████] 100% ✅                  │
│   ├─ 执行流多视图+导出       [████████████████████] 100% ✅                  │
│   └─ 多标签页编辑            [████████████████████] 100% ✅ 刚完成          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**✅ 刚完成的功能** (2026-01-07 凌晨):

| 序号 | 任务 | 状态 | 说明 |
|------|------|------|------|
| 1 | **多标签页编辑** | ✅ | 可同时打开多文件，拖拽排序 |
| 2 | 执行流多视图 | ✅ | 图形/ftrace/树形 切换 |
| 3 | ftrace 格式优化 | ✅ | 行号 + 内核API标记 + 异步机制标记 |
| 4 | 导出功能 | ✅ | 纯文本/Markdown/JSON |
| 5 | 帮助文档弹窗 | ✅ | 格式说明 + 标记含义 |
| 6 | 编辑器高度修复 | ✅ | 解决无法滚动到底的问题 |

**✅ 之前完成的 UI/UX 改进**:

| 序号 | 任务 | 状态 | 说明 |
|------|------|------|------|
| 1 | 历史导航 (后退/前进) | ✅ | ◀ ▶ 按钮 + Alt+←/→ + 鼠标侧键 |
| 2 | 隐藏内核API开关 | ✅ | 100+ 内核函数过滤 |
| 3 | 代码→图联动 | ✅ | 光标自动高亮对应节点 |
| 4 | 命令面板 (Ctrl+P) | ✅ | 模糊搜索文件/符号 |

**🎯 下一步工作重点**:
- LSP 集成 (clangd) - 智能补全、跳转定义
- 多标签页编辑
- CLI trace 命令增强 (可选)
- Phase 0 测试框架补充

**📅 延后任务**:
- LSP 集成 (clangd) → v1.1

**✅ 已完成** (2026-01-07):
- 多标签页编辑
- 面包屑导航
- 按深度折叠 (1-5 层)
- 子树聚焦 (右键菜单)
- 文件保存 (Ctrl+S)

---

### 5.1.2 ⭐ 执行流多视图 + CLI 交互 (高优先级)

> 基于用户反馈：程序员更喜欢 ftrace 风格的文本输出

**功能概述**：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        执行流多视图架构                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   用户输入: 函数名 (e.g. "async_demo_init")                                  │
│                       │                                                      │
│                       ▼                                                      │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    FlowSight 分析引擎                                │   │
│   │            (生成统一的 FlowTree 数据结构)                            │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                       │                                                      │
│         ┌─────────────┼─────────────┬─────────────┐                         │
│         ▼             ▼             ▼             ▼                         │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐                   │
│   │ 图形视图  │  │ ftrace   │  │ 缩进文本  │  │ Markdown │                   │
│   │ (React   │  │ 风格视图  │  │ 树形视图  │  │ 导出     │                   │
│   │  Flow)   │  │          │  │          │  │          │                   │
│   └──────────┘  └──────────┘  └──────────┘  └──────────┘                   │
│        │              │             │             │                         │
│        └──────────────┴─────────────┴─────────────┘                         │
│                       │                                                      │
│         ┌─────────────┴─────────────┐                                       │
│         ▼                           ▼                                       │
│   ┌──────────────┐          ┌──────────────┐                                │
│   │   UI 界面    │          │   CLI 终端   │                                │
│   │  (Tauri)     │          │ (flowsight)  │                                │
│   └──────────────┘          └──────────────┘                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**1. 多视图模式 (UI 内切换)**

| 视图模式 | 描述 | 使用场景 |
|----------|------|----------|
| 📊 图形 (当前) | React Flow 交互式图谱 | 浏览复杂调用关系 |
| 📝 ftrace | 类似 ftrace 的缩进文本 | 内核开发者习惯 |
| 🌲 树形 | 简洁的缩进树 | 快速浏览 |
| 📋 列表 | 平铺调用链 | 搜索特定函数 |

**ftrace 风格示例**:
```
 0)               |  async_demo_init() {
 0)               |    platform_driver_register() {
 0)   ........    |      __platform_driver_register();
 0)               |    }
 0)               |    INIT_WORK() {           /* 异步 */
 0)   --------    |      → demo_work_handler   /* WorkQueue */
 0)               |    }
 0)               |    setup_timer() {         /* 异步 */
 0)   --------    |      → demo_timer_callback /* Timer */
 0)               |    }
 0)               |  }
```

**2. 导出功能**

| 格式 | 描述 |
|------|------|
| Markdown | 带代码块的文档，可嵌入 README |
| 纯文本 | ftrace 风格，可粘贴到邮件/聊天 |
| JSON | 机器可读，供其他工具使用 |
| SVG | 图形导出为图片 |

**3. CLI 交互模式**

```bash
# 查询单个函数的执行流
$ flowsight trace async_demo_init
 0)               |  async_demo_init() {
 0)               |    platform_driver_register();
 0)               |    INIT_WORK() → demo_work_handler [WorkQueue]
 0)               |    setup_timer() → demo_timer_callback [Timer]
 0)               |  }

# 查询谁调用了某函数
$ flowsight callers demo_work_handler
Called by:
  → async_demo_init() via WorkQueue (INIT_WORK)
  → async_demo_probe() via schedule_work()

# 查询某函数调用了谁
$ flowsight callees async_demo_init
async_demo_init() calls:
  ├── platform_driver_register() [Direct]
  ├── INIT_WORK() [Async → demo_work_handler]
  ├── setup_timer() [Async → demo_timer_callback]
  └── pr_info() [Direct]

# 导出 Markdown
$ flowsight trace async_demo_init --format markdown > flow.md

# 交互模式
$ flowsight -i
flowsight> trace async_demo_init
...
flowsight> callers demo_work_handler
...
flowsight> exit
```

**4. 实现计划**

| 序号 | 任务 | 预估时间 | 优先级 |
|------|------|----------|--------|
| 1 | **ftrace 格式渲染器** | 2h | ⭐⭐⭐ |
| 2 | **视图切换 UI** (工具栏按钮) | 1h | ⭐⭐⭐ |
| 3 | **Markdown 导出** | 2h | ⭐⭐⭐ |
| 4 | **纯文本/JSON 导出** | 1h | ⭐⭐ |
| 5 | **CLI trace 命令** | 3h | ⭐⭐ |
| 6 | **CLI callers/callees** | 2h | ⭐⭐ |
| 7 | **CLI 交互模式** | 3h | ⭐ |
| 8 | **SVG 图片导出** | 2h | ⭐ |

**状态** (2026-01-06 更新): 
- [x] ftrace 格式渲染器 ✅
- [x] 视图切换 UI ✅
- [x] Markdown 导出 ✅
- [x] 帮助文档弹窗 ✅
- [ ] CLI 命令增强 (延后，GUI 已足够使用)

---

### 5.2 Phase 0: 原型验证 (8 周) ✅ 基本完成

**目标**: 验证核心技术可行性

**状态**: 核心功能已完成，测试框架延后

*   [x] 项目仓库初始化
*   [x] Rust workspace 结构
*   [x] tree-sitter-c 集成与 AST 遍历
*   [x] 异步模式匹配原型 (work_struct)
*   [x] 简单 UI 原型 (Tauri + React Flow)
*   [~] **基础测试框架** — 🔜 *延后到 Phase 2 UI 稳定后再补充*

### 5.3 Phase 1: 核心引擎增强 (12 周)

**目标**: 完成分析引擎核心功能，解决大型项目支持问题

#### 5.3.1 基础架构层 (关键！影响后续所有功能)

*   **增量解析引擎**:
    *   [x] 改造 TreeSitterParser，保存 Tree 用于增量更新
    *   [ ] 实现 `IncrementalParser` trait，支持局部代码变更
    *   [x] 实现 `TreeCache`，缓存已解析的语法树
*   **增量索引系统**:
    *   [ ] 数据库添加 `files` 表，记录文件 hash/mtime
    *   [x] 实现 `FileVersionTracker`，检测需要重新索引的文件
    *   [x] 实现 `BatchIndexer`，批量插入优化（事务 + 预编译语句）
    *   [ ] 支持局部更新：修改代码后只重新分析变更的函数
*   **并行处理**:
    *   [ ] 使用 rayon 并行解析多文件
    *   [ ] 并行构建索引

#### 5.3.2 大型项目支持 (2000万+ 行代码)

*   **内存管理**:
    *   [ ] 实现 LRU 缓存策略，限制内存中的 Tree 数量
    *   [ ] 按需加载：只加载当前编辑文件 + 相关文件
    *   [ ] 实现文件分片：超大文件分块解析
*   **性能优化**:
    *   [ ] 首次索引后保存到磁盘，下次启动直接加载
    *   [ ] 后台线程持续索引，不阻塞 UI
    *   [ ] 实现索引优先级：用户打开的文件优先索引

#### 5.3.3 进度报告系统

*   **后端**:
    *   [ ] 定义 `ProgressEvent` 结构 (phase, current, total, message)
    *   [ ] 在解析/索引过程中发送进度事件
    *   [ ] 通过 Tauri Events 推送到前端
*   **前端**:
    *   [x] 实现 `ProgressIndicator` 组件
    *   [ ] 显示索引进度 (文件数/总数)
    *   [ ] 显示当前阶段 (解析中/分析中/索引中)
    *   [ ] 支持取消操作

#### 5.3.4 分析能力增强

*   **LSP 集成**: 实现与 `clangd` 的通信，获取精确符号信息
*   **Kconfig 解析**: 读取 `.config` 文件，构建条件编译上下文
*   [x] **高级异步追踪**: 支持 timer, tasklet, irq 等 15+ 种模式
*   [x] **函数指针解析**: 实现基于 ops 表和变量赋值的解析算法
*   **完整 Linux 内核模式识别**:
    *   [x] 覆盖所有常见异步机制 (work, timer, tasklet, softirq, kthread, rcu)
    *   [x] 覆盖驱动框架 (USB, PCI, I2C, SPI, Platform, Block, Net)
    *   [ ] 覆盖文件系统 VFS 回调
    *   [ ] 覆盖网络子系统回调

### 5.4 Phase 2: IDE 交互体验 (12 周)

**目标**: 打造流畅的交互式 IDE

#### 5.4.0 技术选型决策

**代码编辑器**（完整 IDE 体验）:

| 组件 | 选择 | 理由 |
|------|------|------|
| 编辑器核心 | **Monaco Editor** | VS Code 同款，功能完整，生态成熟 |
| LSP 集成 | **monaco-languageclient** | 连接 clangd/rust-analyzer 等 LSP |
| 文件管理 | Tauri fs API | 读写本地文件系统 |

**执行流可视化**:

| 阶段 | 选择 | 理由 |
|------|------|------|
| v0.x ~ v1.0 | **React Flow** | 开发效率高，内置拖拽/缩放，支持 1000+ 节点 |
| v1.x (如性能不够) | Canvas + dagre | 虚拟化渲染，支持 10000+ 节点 |

> 💡 **设计原则**: FlowSight = 完整代码编辑器 + 实时执行流可视化 + AI 理解
> 
> 目标：成为开发者最喜欢的代码阅读和编辑工具，取代现有 IDE。
> 
> 核心优势：改代码 → 实时看到执行流变化 → 真正理解代码

#### 5.4.0.1 ⭐ 短期 UI/UX 改进 — ✅ 已完成

> **状态**: 已完成 (2026-01-06)  
> **来源**: 实际使用反馈  
> **实际用时**: ~3h

| # | 功能 | 优先级 | 状态 | 实际工时 |
|---|------|--------|------|----------|
| 1 | 历史导航 (后退/前进) | 🔴 最高 | ✅ 完成 | 1h |
| 2 | 隐藏内核API开关 | 🔴 最高 | ✅ 完成 | 0.5h |
| 3 | 代码→图联动 | 🟡 中等 | ✅ 完成 | 0.5h |
| 4 | 命令面板 (Ctrl+P) | 🟢 一般 | ✅ 完成 | 1h |

**1. 导航体验 ✅**:
*   [x] **历史导航 (后退/前进)** - 点击函数跳转后能一键返回
    *   维护导航历史栈
    *   工具栏添加 ◀ ▶ 按钮
    *   支持 Alt+← / Alt+→ 快捷键
    *   支持鼠标侧键后退
*   [ ] 面包屑导航 - 显示当前位置在调用链中的路径 *(延后)*

**2. 执行流图降噪 ✅**:
*   [x] **"隐藏内核API"开关** - 一键隐藏 `kmalloc`, `printk`, `spin_lock` 等
    *   在工具栏添加 "⚙️ 内核API" 过滤按钮
    *   内置 100+ 常见内核函数列表
*   [x] **子树聚焦** - 右键节点 -> "只看此分支" + 聚焦模式
*   [x] **按深度折叠** - 工具栏层级选择器 (1-5) + 快捷键

**3. 代码编辑器增强 ✅**:
*   [x] 代码 -> 图联动 - 光标在函数名上时，高亮对应流图节点
*   [ ] Ctrl+Click 跳转定义 - 点击函数名跳转到定义 *(需要 LSP)*

**4. 命令面板 ✅**:
*   [x] Ctrl+P / Cmd+P 居中弹出搜索框
*   [x] 支持搜索文件和符号 (@ 前缀搜符号)
*   [x] 支持模糊匹配

#### 5.4.1 完整代码编辑器 (Monaco Editor)

**基础编辑功能**:
*   [x] Monaco Editor 集成
*   [ ] 多标签页编辑
*   [x] 语法高亮 (C/C++/Rust/Go/Java/...)
*   [x] 代码折叠
*   [ ] 查找替换 (支持正则)
*   [ ] 多光标编辑
*   [ ] 自动保存

**LSP 集成 (智能编辑)**:
*   [ ] clangd 集成 (C/C++)
*   [ ] 自动补全
*   [ ] 跳转到定义 / 查找引用
*   [ ] 悬停显示文档
*   [ ] 重命名符号
*   [ ] 代码诊断 (错误/警告)

**项目管理**:
*   [x] 目录树浏览器
*   [ ] 文件创建/删除/重命名
*   [ ] 文件搜索 (Ctrl+P)
*   [x] 全局搜索 (符号搜索)
*   [ ] 最近打开的项目

**实时同步**:
*   [ ] ⭐ 代码修改 → 增量重新分析 → 执行流图实时更新
*   [ ] 编辑器光标位置 ↔ 图中高亮对应节点
*   [x] 图中点击节点 → 编辑器跳转到对应代码

#### 5.4.2 交互式执行流图谱 (使用 React Flow)

*   **基础交互**:
    *   [ ] 节点点击跳转代码
    *   [ ] 拖拽平移、滚轮缩放
    *   [ ] 节点悬停显示详情 (函数签名、调用次数、执行上下文)
    *   [ ] 边点击显示调用类型 (直接/异步/函数指针)
*   **智能折叠** (关键！避免图谱过于复杂):
    *   [ ] 一键折叠不关心的子系统分支
    *   [ ] 自动识别可折叠的重复模式
    *   [ ] 折叠状态持久化
    *   [ ] 默认只展开 2 层
*   **智能聚类**:
    *   [ ] 自动聚合过于复杂的调用关系
    *   [ ] 按模块/目录聚类
    *   [ ] 用户可自定义聚类规则

#### 5.4.3 场景化数据流分析 ⭐⭐⭐ 核心功能

> 用户指定入口参数值 → 看到每个变量在该场景下的值 → 高亮实际执行路径

**场景输入方式（5种）**:

*   **方式1: GUI表单输入**（简单场景）
    *   [ ] 选择入口函数
    *   [ ] 自动解析参数类型，生成表单
    *   [ ] 支持结构体字段展开
    *   [ ] 支持指针状态（非空/NULL）
    *   [ ] 实时预览

*   **方式2: 代码方式输入**（复杂场景）
    *   [ ] 设计场景描述语言 (`.scenario.c`)
    *   [ ] 支持 SCENARIO("name") { ... } 语法
    *   [ ] 支持 MOCK_FUNCTION() 模拟外部函数返回值
    *   [ ] 支持 EXPECT_PATH_TAKEN() 等断言
    *   [ ] 代码高亮和补全
    *   [ ] 可作为自动化测试执行

*   **方式3: 场景模板库**（常见模式）
    *   [ ] 内置常见驱动框架场景模板
    *   [ ] 分类浏览：USB/I2C/SPI/Platform...
    *   [ ] 模板包含：正常路径、错误路径、边界条件
    *   [ ] 支持用户自定义模板
    *   [ ] 模板分享/导入

*   **方式4: 从调用点提取**
    *   [ ] 分析代码中所有调用入口函数的位置
    *   [ ] 自动提取调用时的参数上下文
    *   [ ] 一键生成场景
    *   [ ] 显示调用链上下文

*   **方式5: 从Trace导入**
    *   [ ] 导入 ftrace/perf 运行时记录
    *   [ ] 从寄存器/内存提取参数值
    *   [ ] 自动生成对应场景
    *   [ ] 对比静态分析 vs 实际运行

**场景管理**:
*   [ ] 保存/加载场景配置
*   [ ] 场景分组和标签
*   [ ] 多场景对比视图
*   [ ] 场景导出（可分享给团队）

**数据流追踪**:
*   [ ] 常量传播分析
*   [ ] 表达式求值 (如 `x >> 8`, `a + b`)
*   [ ] 条件分支判定 (根据变量值判断走哪个分支)
*   [ ] 循环迭代追踪 (可配置迭代次数)
*   [ ] 指针/引用追踪

**可视化展示**:
*   [ ] 执行流图：每个节点显示当前变量值
*   [ ] 执行流图：高亮实际会执行的路径
*   [ ] 执行流图：灰显不会执行的分支
*   [ ] 代码编辑器：行内显示变量值 (类似调试器)
*   [ ] 变量面板：显示当前选中节点的所有变量值

**AI 辅助推断**:
*   [ ] 对于无法静态确定的值，用 AI 推断可能的范围
*   [ ] 对于复杂表达式，用 AI 解释计算过程

**技术实现**:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    场景化数据流分析引擎架构                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   用户输入                                                                   │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  场景: usb_probe(interface, id)                                     │   │
│   │        id->idVendor = 0x1234                                        │   │
│   │        id->idProduct = 0x5678                                       │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    符号执行引擎 (flowsight-symbolic)                 │   │
│   │                                                                      │   │
│   │  1. 初始化符号表: { id->idVendor: 0x1234, id->idProduct: 0x5678 }  │   │
│   │  2. 遍历 AST，对每个语句：                                          │   │
│   │     • 赋值语句 → 更新符号表                                         │   │
│   │     • 条件语句 → 求值条件，记录分支选择                             │   │
│   │     • 函数调用 → 递归分析或标记为"需要更多信息"                     │   │
│   │  3. 输出: 每个程序点的变量值 + 执行路径                             │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                         可视化渲染                                   │   │
│   │                                                                      │   │
│   │  • 节点标注变量值                                                   │   │
│   │  • 高亮执行路径 (绿色)                                              │   │
│   │  • 灰显未执行分支                                                   │   │
│   │  • 代码行内显示值                                                   │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 5.4.4 高级数据流可视化 ⭐⭐ 核心 UI

> 针对不同数据类型和场景的专业可视化

**内存生命周期视图**:
*   [ ] 时间线显示内存分配/释放
*   [ ] 高亮未释放的内存（泄漏风险）
*   [ ] 显示 error 路径是否正确清理
*   [ ] 悬停显示分配详情（大小、位置、释放点）

**变量追踪视图**:
*   [ ] 选中变量后显示值变化时间线
*   [ ] 在执行流图中标注值变化点
*   [ ] 变量监视面板（类似调试器 Watch）
*   [ ] 支持表达式监视（如 `dev->status & 0xFF`）

**函数指针关系图**:
*   [ ] ops 表结构可视化
*   [ ] 显示"谁调用了这个指针"
*   [ ] 显示"这个指针指向哪些函数"
*   [ ] 调用场景说明（何时触发）

**中断/信号时间线**:
*   [ ] 多层时间线（进程上下文/软中断/硬中断）
*   [ ] 上下文切换可视化
*   [ ] 显示每个上下文的限制（可睡眠/不可睡眠）
*   [ ] 异步触发关系连线

**并发执行视图**:
*   [ ] 多线程/多 CPU 时间线
*   [ ] 锁的获取/等待/释放可视化
*   [ ] 临界区高亮
*   [ ] 潜在竞态条件检测和警告
*   [ ] 死锁风险分析

**UI 交互设计**:
*   [ ] 视图切换：执行流 / 内存 / 变量 / 并发
*   [ ] 视图联动：选中一个视图的元素，其他视图同步高亮
*   [ ] 时间线缩放和拖拽
*   [ ] 筛选和搜索

#### 5.4.5 图谱渲染性能优化

*   **React Flow 优化**:
    *   [ ] 使用 `nodeTypes` 自定义节点减少重渲染
    *   [ ] 使用 `useMemo` 缓存节点和边数据
    *   [ ] 开启 `fitView` 和 `minZoom/maxZoom` 限制
*   **大图谱优化 (1000+ 节点)**:
    *   [ ] 使用 Web Worker 计算 dagre 布局
    *   [ ] 节点虚拟化：只渲染视口内的节点
    *   [ ] 边简化：缩放时隐藏小边
*   **渐进式渲染**:
    *   [ ] 先渲染主路径，再补充细节
    *   [ ] 缩放时动态调整细节层次 (LOD)

#### 5.4.6 代码透视模式 (Code Lens)

> 在代码行上方显示额外信息，帮助快速理解代码

*   [ ] 显示 "⚡ Entry point | Called by: xxx()"
*   [ ] 显示 "🔗 Binds → my_handler() (async)"
*   [ ] 显示执行上下文标记 (可休眠 ✅ / 不可休眠 ⚠️)
*   [ ] 可开关，避免信息过载

#### 5.4.7 知识库 GUI

*   [ ] 实现简单的规则编辑器，允许用户可视化添加规则
*   [ ] 支持从代码选区自动生成规则模板

#### 5.4.8 IDE 完整功能 (v1.0+)

**终端集成**:
*   [ ] 内置终端 (基于 xterm.js)
*   [ ] 多终端标签页
*   [ ] 自动 cd 到项目目录

**Git 集成**:
*   [ ] Git 状态显示 (修改/新增/删除)
*   [ ] 基础 Git 操作 (commit/push/pull)
*   [ ] 差异对比视图
*   [ ] 分支切换

**设置与主题**:
*   [ ] 用户设置持久化
*   [ ] 多种主题 (深色/浅色/高对比)
*   [ ] 快捷键自定义
*   [ ] 字体大小/行高调整

**布局系统**:
*   [ ] 可拖拽调整面板大小
*   [ ] 面板显示/隐藏
*   [ ] 多种布局预设 (编辑器+图谱 左右/上下)
*   [ ] 布局保存与恢复

### 5.5 Phase 3: 完善与 Trace 集成 (12 周)

**目标**: 动态分析支持与准确性验证

#### 5.5.1 Trace 数据导入 (flowsight-trace 新模块)

*   **支持格式**:
    *   [ ] ftrace (text/binary)
    *   [ ] perf.data
    *   [ ] systrace
    *   [ ] LTTng
*   **核心功能**:
    *   [ ] `FtraceImporter`: 解析 ftrace 日志
    *   [ ] `PerfDataParser`: 解析 perf.data
    *   [ ] `TraceMapper`: 将函数地址/符号映射到源码位置
    *   [ ] 流式解析：支持超大 Trace 文件 (GB级)

#### 5.5.2 动态分析可视化

*   **热力图**:
    *   [ ] 在调用图上用颜色深浅表示调用频率
    *   [ ] 显示函数执行时间统计
*   **路径高亮**:
    *   [ ] 高亮实际执行过的路径
    *   [ ] 显示执行时间线
*   **对比视图**:
    *   [ ] 静态分析 vs 实际执行对比
    *   [ ] 发现未覆盖的代码路径

#### 5.5.3 智能文档

*   [ ] 一键导出当前分析视图为 Markdown/HTML 报告
*   [ ] 包含 SVG 流程图、函数说明、关键数据结构定义
*   [ ] 适用于技术评审、交接文档

### 5.6 Phase 4: AI 集成 (8 周) ⭐

**目标**: v1.5 版本，集成 AI 能力

#### 5.6.1 AI 基础架构

*   **新增 crate: flowsight-ai**:
    *   [ ] `AIBackend` trait: 抽象不同 AI 后端
    *   [ ] `OllamaBackend`: 本地模型支持 (Ollama)
    *   [ ] `OpenAIBackend`: OpenAI API 支持
    *   [ ] `AnthropicBackend`: Claude API 支持
    *   [ ] 流式响应处理
*   **Prompt 工程**:
    *   [ ] 设计上下文感知的提示词模板
    *   [ ] 代码片段 + 调用图 + 用户问题 → 结构化 Prompt
    *   [ ] 多轮对话上下文管理

#### 5.6.2 核心 AI 功能

*   **自然语言查询**:
    *   [ ] 用户输入 "找到 USB 热插拔流程"
    *   [ ] AI 理解意图，生成图查询
    *   [ ] 返回相关执行流图 + 解释
*   **代码解释**:
    *   [ ] 选中代码 → "解释这段代码"
    *   [ ] 结合调用图上下文生成解释
    *   [ ] 标注关键点和潜在问题
*   **文档生成**:
    *   [ ] 选择函数 → "生成文档"
    *   [ ] 自动生成包含 SVG 流程图的 Markdown
    *   [ ] 支持自定义模板

#### 5.6.3 AI 设置界面

*   [ ] 后端选择 (本地/云端)
*   [ ] API Key 管理 (安全存储)
*   [ ] 模型选择 (如有多个)
*   [ ] 上下文长度限制设置

---

### 5.7 Phase 5: 质量保证与发布 (12 周)

**目标**: v1.0/v1.5 正式版发布

#### 5.7.1 测试体系

*   **单元测试**:
    *   [ ] 每个模块 80%+ 覆盖率
    *   [ ] 异步模式识别准确性测试
*   **集成测试**:
    *   [ ] 使用真实 Linux 内核代码片段测试
    *   [ ] 收集 50+ 个典型驱动作为测试用例
    *   [ ] 验证异步追踪准确性 (人工标注 ground truth)
*   **性能测试**:
    *   [ ] Linux 内核全量索引时间 < 10 分钟
    *   [ ] 增量更新时间 < 1 秒
    *   [ ] 图谱渲染 1000 节点 60fps
*   **自动化 CI/CD**:
    *   [ ] GitHub Actions 自动运行测试
    *   [ ] 自动构建多平台安装包
    *   [ ] 代码质量检查 (clippy, eslint)

#### 5.7.2 发布准备

*   **多平台打包**: Windows, Linux, macOS
*   **国际化**: 完善中英文翻译
*   **插件系统**: 初步支持用户脚本查询图数据库
*   **文档完善**: 用户手册、API 文档、贡献指南

---

## 9. UI/UX 设计

### 9.1 交互式执行流视图

必须支持高度交互的操作，而不仅仅是静态图片：

*   **双击节点**: 跳转到对应源码行。
*   **右键菜单**: "折叠此分支"、"只看此路径"、"高亮相关数据流"。
*   **面包屑导航**: 在深入复杂调用链时，顶部显示当前路径。
*   **Mini Map**: 鸟瞰图，用于在巨大图谱中导航。

### 9.2 代码透视模式 (X-Ray Mode)

在编辑器行内显示增强信息：

```c
static int hub_probe(struct usb_interface *intf, ...)
{
    // [Code Lens] 2 callers | 1 async trigger
    
    struct usb_hub *hub;
    hub = kzalloc(sizeof(*hub), GFP_KERNEL);
    
    // [Code Lens] Binds to: hub_event()
    INIT_WORK(&hub->work, hub_event);
    
    // ...
}
```

### 9.3 智能文档生成

提供 "导出分析报告" 功能：

1.  用户选择一个入口函数（如 `probe`）。
2.  IDE 自动遍历其调用树。
3.  生成包含 SVG 流程图、函数说明、关键数据结构定义的 Markdown 文档。
4.  适用于技术评审、交接文档。

### 9.4 多视图布局设计 ⭐

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        FlowSight 主界面布局                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  📁 文件  📝 编辑  🔍 视图  📊 分析  🎨 场景  🤖 AI  ❓ 帮助              │
├─────────┬───────────────────────────────────────────────────┬───────────────┤
│         │                                                   │               │
│ 📁      │  ┌─ usb_driver.c ─┬─ Makefile ─┬─ + ─┐           │ 📋 大纲      │
│ 文件    │  │                                    │           │ ├─ probe     │
│ 浏览器  │  │  58 │ static int my_probe(...)     │           │ ├─ disconnect│
│         │  │  59 │ {                            │           │ └─ handler   │
│         │  │     │ // dev->type = 0x56 ←场景值 │           │               │
│         │  │  60 │     dev->type = id->...      │           ├───────────────┤
│         │  │  61 │     if (dev->type == 0x56)   │           │ 📊 变量监视  │
│         │  │     │     // ✅ 进入此分支         │           │ ─────────────│
│         │  │  62 │         init_type_a(dev);    │           │ dev->type: 0x56│
│         │  │  63 │     else                     │           │ dev->status: 1│
│         │  │     │     // ❌ 不执行             │           │ ret: 0        │
│         │  │  64 │         init_type_b(dev);    │           │               │
│         │  │                                    │           │               │
│         │  └────────────────────────────────────┘           │               │
│         │                                                   │               │
│         ├───────────────────────────────────────────────────┤               │
│         │  ┌─ 视图切换: [执行流] [内存] [并发] [时间线] ─┐  │               │
│         │  │                                              │  │               │
│         │  │    ┌─────────┐    ┌─────────┐               │  │               │
│         │  │    │my_probe │───→│init_a   │               │  │               │
│         │  │    │type=0x56│    │         │               │  │               │
│         │  │    └────┬────┘    └─────────┘               │  │               │
│         │  │         │                                   │  │               │
│         │  │    ┌────▼────┐                              │  │               │
│         │  │    │INIT_WORK│──异步──→ [handler]          │  │               │
│         │  │    └─────────┘                              │  │               │
│         │  │                                              │  │               │
│         │  └──────────────────────────────────────────────┘  │               │
│         │                                                   │               │
├─────────┴───────────────────────────────────────────────────┴───────────────┤
│  场景: USB设备0x1234:0x5678 │ 索引: 15,234符号 │ 分析: 就绪 │ AI: 已连接   │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.5 视图切换设计

**视图标签栏**:
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  [📊 执行流] [🧠 内存] [🔄 并发] [⏱️ 时间线] [🔗 函数指针]                 │
└─────────────────────────────────────────────────────────────────────────────┘
     ↓            ↓           ↓            ↓              ↓
  调用关系    内存生命周期  锁/线程     中断/信号      ops表关系
```

**视图联动**:
- 在代码编辑器中选中函数 → 所有视图高亮该函数相关内容
- 在执行流图中点击节点 → 编辑器跳转到对应代码
- 在内存视图中点击变量 → 变量监视面板添加该变量
- 在时间线上点击事件 → 跳转到触发该事件的代码

### 9.6 场景管理界面

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          场景管理器                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  当前场景: USB设备0x1234:0x5678                           [保存] [另存为]   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  入口函数: usb_probe                                                │    │
│  │                                                                      │    │
│  │  参数绑定:                                                           │    │
│  │  ┌─────────────────┬─────────────────────────────────┬───────────┐  │    │
│  │  │ 变量路径        │ 值                               │ 操作     │  │    │
│  │  ├─────────────────┼─────────────────────────────────┼───────────┤  │    │
│  │  │ id->idVendor    │ 0x1234                          │ [删除]   │  │    │
│  │  │ id->idProduct   │ 0x5678                          │ [删除]   │  │    │
│  │  │ interface       │ <非空指针>                      │ [删除]   │  │    │
│  │  └─────────────────┴─────────────────────────────────┴───────────┘  │    │
│  │                                                                      │    │
│  │  [+ 添加参数]                                                        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  已保存的场景:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ • USB设备0x1234:0x5678 (当前)                                       │    │
│  │ • USB设备0xABCD:0xEF01                                              │    │
│  │ • 错误处理路径测试                                                   │    │
│  │ • 内存分配失败场景                                                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  [🔄 分析当前场景]  [📊 对比多个场景]  [📤 导出报告]                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.7 问题检测和警告设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          问题检测面板                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  🔍 检测到 3 个潜在问题                                                     │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ ⚠️ 内存泄漏风险                                          [跳转]    │    │
│  │    文件: usb_driver.c:76                                            │    │
│  │    描述: dev->buffer 在 error_buffer 路径未释放                     │    │
│  │    建议: 在 goto error_buffer 前添加 kfree(dev->buffer)             │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ ⚠️ 可能在中断上下文休眠                                  [跳转]    │    │
│  │    文件: usb_driver.c:120                                           │    │
│  │    描述: my_timer_handler 调用了 kmalloc(GFP_KERNEL)                │    │
│  │    建议: 在软中断上下文使用 GFP_ATOMIC                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ ℹ️ 未使用的函数                                          [跳转]    │    │
│  │    文件: usb_driver.c:200                                           │    │
│  │    描述: debug_dump() 未被任何代码调用                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  [🔄 重新扫描]  [⚙️ 配置检测规则]  [📤 导出报告]                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 10. 架构改进详细设计

### 10.1 增量解析架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           增量解析系统                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   文件修改                                                                   │
│      │                                                                       │
│      ▼                                                                       │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐                   │
│   │ FileWatcher │ ──→ │ TreeCache   │ ──→ │ Incremental │                   │
│   │ (检测变更)  │     │ (获取旧Tree)│     │ Parser      │                   │
│   └─────────────┘     └─────────────┘     └─────────────┘                   │
│                                                  │                           │
│                                                  ▼                           │
│                       ┌─────────────┐     ┌─────────────┐                   │
│                       │ BatchIndexer│ ←── │ DiffAnalyzer│                   │
│                       │ (增量更新DB)│     │ (找出变化)  │                   │
│                       └─────────────┘     └─────────────┘                   │
│                                                                              │
│   关键数据结构：                                                             │
│   • TreeCache: HashMap<PathBuf, (Tree, u64 /* file_hash */)>                │
│   • FileVersion: { path, hash, mtime, indexed_at }                          │
│   • ChangedSymbols: { added: [], removed: [], modified: [] }                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.2 大型项目内存管理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           内存管理策略                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  三级缓存                                                            │   │
│   │                                                                      │   │
│   │  Level 1: 热数据 (当前打开的文件)                                    │   │
│   │  ├── 完整 Tree + ParseResult                                         │   │
│   │  └── 无限制，随打开文件数增长                                        │   │
│   │                                                                      │   │
│   │  Level 2: 温数据 (最近访问的相关文件)                                │   │
│   │  ├── 完整 Tree + ParseResult                                         │   │
│   │  └── LRU 淘汰，最大 100 个文件                                       │   │
│   │                                                                      │   │
│   │  Level 3: 冷数据 (SQLite 持久化)                                     │   │
│   │  ├── 只保存符号信息，不保存 Tree                                     │   │
│   │  └── 需要时从源文件重新解析                                          │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   淘汰策略：                                                                 │
│   • 内存超过阈值时，Level 2 按 LRU 淘汰到 Level 3                          │
│   • 用户关闭文件时，从 Level 1 移到 Level 2                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.3 进度报告系统

```rust
// 进度事件定义
#[derive(Serialize, Clone)]
pub struct ProgressEvent {
    pub phase: ProgressPhase,
    pub current: u64,
    pub total: u64,
    pub message: String,
    pub cancelable: bool,
}

#[derive(Serialize, Clone)]
pub enum ProgressPhase {
    Scanning,      // 扫描文件
    Parsing,       // 解析代码
    Analyzing,     // 分析异步/函数指针
    Indexing,      // 写入索引
    BuildingGraph, // 构建调用图
}

// 前端订阅
tauri::listen("indexing-progress", |event| {
    const progress = event.payload;
    updateProgressBar(progress.current / progress.total);
    updateStatusText(progress.message);
});
```

### 10.4 智能折叠算法

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           智能折叠策略                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   规则 1: 深度折叠                                                           │
│   • 默认只展开 2 层                                                          │
│   • 超过深度的节点自动折叠为 "... (5 more calls)"                           │
│                                                                              │
│   规则 2: 子系统折叠                                                         │
│   • 识别子系统边界 (如 drivers/usb/, fs/, net/)                             │
│   • 进入其他子系统的调用可折叠为 "[USB subsystem]"                          │
│                                                                              │
│   规则 3: 重复模式折叠                                                       │
│   • 检测重复的调用模式 (如 多个 kfree() 调用)                               │
│   • 聚合为 "kfree() x 3"                                                    │
│                                                                              │
│   规则 4: 内核 API 折叠                                                      │
│   • 常见内核 API (kmalloc, printk, spin_lock 等) 可一键隐藏                 │
│   • 用户可配置 "不关心的函数列表"                                           │
│                                                                              │
│   交互：                                                                     │
│   • 点击折叠节点展开详情                                                     │
│   • 右键菜单: "只看这条路径" / "隐藏这个分支"                               │
│   • 快捷键: Ctrl+F 聚焦当前函数的调用链                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.5 新增 Crate: flowsight-trace

```
crates/flowsight-trace/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── ftrace.rs       # ftrace 日志解析
│   ├── perf.rs         # perf.data 解析
│   ├── systrace.rs     # systrace 解析
│   ├── mapper.rs       # 地址/符号 → 源码映射
│   └── timeline.rs     # 时间线数据结构
```

### 10.6 场景描述语言设计 (FlowSight Scenario Language)

> 用代码方式定义复杂分析场景，支持模拟、断言和自动化测试

#### 语法设计

```c
// 文件: my_driver.scenario.c
#include <flowsight/scenario.h>

// ============================================
// 场景1: USB 设备正常探测
// ============================================
SCENARIO("USB Type A 设备正常探测") {
    DESCRIPTION("测试 USB 设备 0x1234:0x5678 的探测流程");
    TAGS("usb", "probe", "happy-path");
    
    // 入口函数
    ENTRY(usb_probe);
    
    // 定义输入参数
    PARAM(struct usb_interface*, interface) {
        .dev.driver = &my_driver,
        .cur_altsetting = VALID_POINTER,
    };
    
    PARAM(const struct usb_device_id*, id) {
        .idVendor = 0x1234,
        .idProduct = 0x5678,
        .bDeviceClass = USB_CLASS_VENDOR_SPEC,
    };
    
    // 模拟外部函数行为
    MOCK(kzalloc) {
        ON_CALL(ANY, GFP_KERNEL).RETURN(VALID_POINTER);
    }
    
    MOCK(kmalloc) {
        ON_CALL(4096, GFP_KERNEL).RETURN(VALID_POINTER);
    }
    
    MOCK(usb_get_dev) {
        RETURN(VALID_POINTER);
    }
    
    // 运行分析
    RUN();
    
    // 验证执行路径
    EXPECT_PATH("init_type_a");
    EXPECT_NOT_PATH("init_type_b");
    EXPECT_NOT_PATH("error_buffer");
    
    // 验证变量值
    EXPECT_VAR("dev->type", EQUALS, 0x56);
    EXPECT_VAR("ret", EQUALS, 0);
    
    // 验证返回值
    EXPECT_RETURN(0);
}

// ============================================
// 场景2: 内存分配失败
// ============================================
SCENARIO("USB 探测 - 内存分配失败") {
    DESCRIPTION("测试 kzalloc 返回 NULL 时的错误处理");
    TAGS("usb", "probe", "error-path", "memory");
    
    ENTRY(usb_probe);
    
    PARAM(struct usb_interface*, interface) { ... };
    PARAM(const struct usb_device_id*, id) { ... };
    
    // 模拟内存分配失败
    MOCK(kzalloc) {
        RETURN(NULL);
    }
    
    RUN();
    
    // 验证错误路径
    EXPECT_PATH("error");
    EXPECT_RETURN(-ENOMEM);
    
    // 验证没有内存泄漏（因为分配失败了）
    EXPECT_NO_MEMORY_LEAK();
}

// ============================================
// 场景3: 参数化场景
// ============================================
SCENARIO_TEMPLATE("USB 设备探测", vendor, product) {
    ENTRY(usb_probe);
    
    PARAM(const struct usb_device_id*, id) {
        .idVendor = vendor,
        .idProduct = product,
    };
    
    // ...
}

// 用不同参数实例化
INSTANTIATE(USB_DEVICE_A, 0x1234, 0x5678);
INSTANTIATE(USB_DEVICE_B, 0xABCD, 0xEF01);
INSTANTIATE(USB_DEVICE_C, 0x0000, 0x0000);  // 边界测试
```

#### 内置宏和函数

```c
// 场景定义
SCENARIO(name)              // 定义场景
SCENARIO_TEMPLATE(name, params...)  // 参数化场景模板
DESCRIPTION(text)           // 场景描述
TAGS(...)                   // 标签，用于筛选

// 入口和参数
ENTRY(function)             // 入口函数
PARAM(type, name) { ... }   // 参数定义

// 模拟
MOCK(function) { ... }      // 模拟函数
ON_CALL(args...).RETURN(value)  // 条件返回
RETURN(value)               // 无条件返回
VALID_POINTER               // 有效指针（非NULL）
NULL_POINTER                // 空指针
ANY                         // 任意值

// 执行
RUN()                       // 运行分析

// 断言 - 路径
EXPECT_PATH(name)           // 期望经过此路径
EXPECT_NOT_PATH(name)       // 期望不经过此路径

// 断言 - 变量
EXPECT_VAR(expr, op, value) // 验证变量值
// op: EQUALS, NOT_EQUALS, GREATER, LESS, IN_RANGE

// 断言 - 返回值
EXPECT_RETURN(value)        // 验证返回值

// 断言 - 内存
EXPECT_NO_MEMORY_LEAK()     // 无内存泄漏
EXPECT_MEMORY_FREED(var)    // 变量已释放

// 断言 - 并发
EXPECT_LOCK_HELD(lock)      // 持有锁
EXPECT_LOCK_NOT_HELD(lock)  // 未持有锁
```

### 10.7 新增 Crate: flowsight-symbolic ⭐ 核心

> 场景化数据流分析引擎 —— 让用户指定输入参数，看到变量在每个节点的值

```
crates/flowsight-symbolic/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── scenario.rs     # 场景定义 (用户输入的参数值)
│   ├── symbol_table.rs # 符号表 (变量名 → 值)
│   ├── evaluator.rs    # 表达式求值器
│   ├── executor.rs     # 符号执行引擎
│   ├── branch.rs       # 分支条件判定
│   └── path.rs         # 执行路径记录
```

#### 核心数据结构

```rust
/// 场景定义 - 用户指定的输入参数
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Scenario {
    /// 入口函数
    pub entry_function: String,
    /// 参数值绑定
    pub bindings: Vec<ValueBinding>,
    /// 场景名称 (用于保存/加载)
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValueBinding {
    /// 变量路径 (如 "id->idVendor")
    pub path: String,
    /// 值 (支持整数、字符串、结构体)
    pub value: SymbolicValue,
}

/// 符号值
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SymbolicValue {
    /// 具体整数值
    Integer(i64),
    /// 具体字符串
    String(String),
    /// 指针 (已分配/NULL)
    Pointer { is_null: bool, size: Option<usize> },
    /// 未知值 (需要AI推断或用户指定)
    Unknown { hint: Option<String> },
    /// 范围 (如 0..100)
    Range { min: i64, max: i64 },
}

/// 程序点的状态
#[derive(Debug, Clone)]
pub struct ProgramState {
    /// 当前位置
    pub location: Location,
    /// 符号表 (变量 → 值)
    pub symbols: HashMap<String, SymbolicValue>,
    /// 此路径是否可达
    pub reachable: bool,
    /// 条件分支选择
    pub branch_taken: Option<bool>,
}

/// 执行路径
#[derive(Debug, Clone)]
pub struct ExecutionPath {
    /// 路径上的所有程序状态
    pub states: Vec<ProgramState>,
    /// 路径是否完整执行
    pub completed: bool,
    /// 终止原因 (如果未完成)
    pub termination_reason: Option<String>,
}
```

#### 使用示例

```rust
// 创建场景
let scenario = Scenario {
    entry_function: "usb_probe".to_string(),
    name: "USB设备0x1234:0x5678".to_string(),
    bindings: vec![
        ValueBinding {
            path: "id->idVendor".to_string(),
            value: SymbolicValue::Integer(0x1234),
        },
        ValueBinding {
            path: "id->idProduct".to_string(),
            value: SymbolicValue::Integer(0x5678),
        },
    ],
};

// 执行符号分析
let executor = SymbolicExecutor::new();
let path = executor.execute(&scenario, &parse_result)?;

// 获取每个节点的变量值
for state in &path.states {
    println!("At {}: {:?}", state.location, state.symbols);
}
```

---

## 11. 风险评估与应对 (更新)

| 风险 | 可能性 | 影响 | 应对策略 |
|------|--------|------|----------|
| **LSP 集成复杂** | 中 | 中 | 使用成熟的 `monaco-languageclient` 库，不从零实现 |
| **图谱过于复杂** | 高 | 高 | **必须**实现智能折叠和聚类算法，默认只展开 2 层 |
| **Trace 数据量大** | 中 | 中 | 采用流式解析，只加载当前视图相关的时间段 |
| **Kconfig 解析繁琐** | 中 | 低 | 借用 Linux 内核自带的 `conf` 工具或现有 Python 库 |
| **增量解析实现复杂** | 中 | 高 | 先实现文件级增量，再优化到函数级 |
| **大型项目内存溢出** | 中 | 高 | 实现三级缓存 + LRU 淘汰策略 |
| **索引首次构建慢** | 高 | 中 | 后台线程 + 进度指示 + 优先索引用户打开的文件 |

---

## 12. 资源估算

*   **核心开发**: 2-3 人 (Rust/Tauri)
*   **前端交互**: 1-2 人 (React/D3/Canvas) - **交互式图谱需要重点投入**
*   **测试设备**: Windows 开发机 + Linux 编译服务器

---

## 13. 成功指标

### 13.1 技术指标

| 指标 | 目标值 | 测量方法 |
|------|--------|----------|
| Linux 内核全量索引时间 | < 10 分钟 | 测试 Linux 6.x 完整源码 |
| 增量更新时间 | < 1 秒 | 修改单个文件后的响应时间 |
| 内存占用 (内核项目) | < 4 GB | 索引完成后的稳定内存 |
| 图谱渲染 1000 节点 | 60 fps | 拖拽平移时的帧率 |
| 异步追踪准确率 | > 95% | 与人工标注对比 |

### 13.2 用户体验指标

| 指标 | 目标值 | 测量方法 |
|------|--------|----------|
| 首次使用到看到结果 | < 5 分钟 | 用户测试 |
| 核心功能可发现性 | > 80% | 用户能自己找到主要功能 |
| 任务完成率 | > 90% | 用户能完成典型分析任务 |

### 13.3 社区指标 (开源)

| 指标 | 1年目标 | 3年目标 |
|------|---------|---------|
| GitHub Stars | 1,000+ | 10,000+ |
| 活跃贡献者 | 5+ | 20+ |
| 月下载量 | 500+ | 5,000+ |
| 用户反馈 Issue | 持续收到 | 形成社区 |

---

## 14. 扩展性设计

### 14.1 多语言支持架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           多语言支持架构                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  Language Trait (抽象接口)                                           │   │
│   │                                                                      │   │
│   │  pub trait LanguageSupport {                                         │   │
│   │      fn parse(&self, source: &str) -> ParseResult;                   │   │
│   │      fn get_async_patterns(&self) -> Vec<AsyncPattern>;              │   │
│   │      fn get_funcptr_patterns(&self) -> Vec<FuncPtrPattern>;          │   │
│   │  }                                                                   │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│          ┌──────────────────┼──────────────────┐                            │
│          ▼                  ▼                  ▼                            │
│   ┌────────────┐    ┌────────────┐    ┌────────────┐                        │
│   │ C Language │    │ Rust Lang  │    │ Go Lang    │                        │
│   │ Support    │    │ Support    │    │ Support    │                        │
│   └────────────┘    └────────────┘    └────────────┘                        │
│                                                                              │
│   每种语言实现自己的：                                                       │
│   • tree-sitter grammar                                                     │
│   • 异步模式识别 (tokio, goroutine, etc.)                                   │
│   • 函数指针/trait/interface 解析                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 14.2 知识库扩展架构

```
knowledge/
├── schemas/                    # JSON Schema 定义
│   ├── async_pattern.schema.json
│   ├── framework.schema.json
│   └── bridge.schema.json
├── languages/                  # 语言级别模式
│   ├── c/
│   ├── rust/
│   └── go/
├── platforms/                  # 平台级别模式
│   ├── linux-kernel/
│   ├── android/
│   └── embedded/
└── bridges/                    # 跨语言桥接
    └── jni.yaml
```

**扩展新平台只需：**
1. 创建新目录 `platforms/new-platform/`
2. 编写 YAML 规则文件
3. 无需修改代码，自动加载

### 14.3 插件系统设计 (v2.0+)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           插件系统                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   插件类型：                                                                 │
│   ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐              │
│   │ 语言插件   │ │ 分析插件   │ │ 可视化插件 │ │ 导出插件   │              │
│   │ (新语法)   │ │ (新规则)   │ │ (新图表)   │ │ (新格式)   │              │
│   └────────────┘ └────────────┘ └────────────┘ └────────────┘              │
│                                                                              │
│   插件接口 (Lua/WASM)：                                                      │
│   • register_pattern(name, regex, handler)                                  │
│   • query_callgraph(from, to, depth)                                        │
│   • add_visualization(type, data)                                           │
│   • export_data(format, path)                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 14.4 AI 集成设计 (v1.5+) ⭐

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           AI 集成架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                         AI 功能层                                    │   │
│   │  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐        │   │
│   │  │ 自然语言   │ │ 代码解释   │ │ 文档生成   │ │ Bug 分析   │        │   │
│   │  │ 查询       │ │            │ │            │ │            │        │   │
│   │  └────────────┘ └────────────┘ └────────────┘ └────────────┘        │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                     │                                        │
│                                     ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                       AI 抽象层 (flowsight-ai)                       │   │
│   │  • PromptBuilder: 构建上下文感知的提示词                            │   │
│   │  • RAGEngine: 基于索引的检索增强生成                                │   │
│   │  • StreamHandler: 流式响应处理                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                     │                                        │
│                          ┌──────────┴──────────┐                            │
│                          ▼                     ▼                            │
│   ┌─────────────────────────────┐ ┌─────────────────────────────┐           │
│   │      本地模型后端           │ │      云端 API 后端          │           │
│   │  • Ollama (Llama/Qwen)      │ │  • OpenAI API               │           │
│   │  • llama.cpp                │ │  • Anthropic API            │           │
│   │  • MLX (Apple Silicon)      │ │  • Azure OpenAI             │           │
│   │                             │ │  • 其他兼容 API             │           │
│   │  优点: 隐私、离线可用       │ │  优点: 更强大、无需GPU      │           │
│   └─────────────────────────────┘ └─────────────────────────────┘           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### AI 功能详细设计

**v1.5 - 基础 AI 功能：**

| 功能 | 描述 | 实现方式 |
|------|------|----------|
| **自然语言查询** | "找到 USB 热插拔的处理流程" | AI 理解意图 → 生成图查询 → 返回执行流 |
| **代码解释** | 选中代码 → 解释功能 | 代码 + 上下文 → AI 生成解释 |
| **文档生成** | 选择函数 → 生成文档 | 调用图 + 代码 → Markdown |

**v2.0 - 高级 AI 功能：**

| 功能 | 描述 | 实现方式 |
|------|------|----------|
| **代码问答 (RAG)** | 任意问题 → 准确回答 | 检索相关代码 → 增强上下文 → 生成答案 |
| **Bug 分析** | 崩溃点 → 分析原因 | 执行路径 + 上下文 → AI 分析 |
| **代码审查** | 补丁 → 影响分析 | 差异 + 调用图 → 影响范围 |

**技术选型：**
- 用户可选择本地模型或云端 API
- 本地模型推荐：Ollama + Qwen2.5-Coder / DeepSeek-Coder
- 云端 API 支持：OpenAI、Anthropic、Azure 等
