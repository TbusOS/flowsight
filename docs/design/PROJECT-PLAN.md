# 🔭 FlowSight 项目规划书

> **下一代跨平台代码编辑器 IDE**
> 
> 让你看到代码的"灵魂"——执行流、异步调用、数据结构关系
> 
> 🎯 **愿景**：成为全球开发者最喜爱的代码阅读和编辑工具
> 
> ⭐ **核心差异**：完整代码编辑 + 实时执行流可视化 + AI 代码理解
> 
> 📍 **首发支持**：Linux 内核 → Android → 更多平台

---

## 📋 目录

1. [项目愿景](#1-项目愿景)
2. [核心价值主张](#2-核心价值主张)
3. [技术架构设计](#3-技术架构设计)
4. [技术选型](#4-技术选型)
5. [详细开发计划](#5-详细开发计划)
   - [5.2 Phase 0: 原型验证](#52-phase-0-原型验证-8-周)
   - [5.3 Phase 1: 核心引擎增强](#53-phase-1-核心引擎增强-12-周) ⭐ 关键
   - [5.4 Phase 2: IDE 交互体验](#54-phase-2-ide-交互体验-12-周)
   - [5.5 Phase 3: Trace 集成](#55-phase-3-完善与-trace-集成-12-周)
   - [5.6 Phase 4: AI 集成](#56-phase-4-ai-集成-8-周) ⭐ 新增
   - [5.7 Phase 5: 质量保证与发布](#57-phase-5-质量保证与发布-12-周)
6. [里程碑定义](#6-里程碑定义)
7. [项目结构](#7-项目结构)
8. [核心算法设计](#8-核心算法设计)
9. [UI/UX 设计](#9-uiux-设计)
10. [架构改进详细设计](#10-架构改进详细设计) ⭐ 新增
    - [10.1 增量解析架构](#101-增量解析架构)
    - [10.2 大型项目内存管理](#102-大型项目内存管理)
    - [10.3 进度报告系统](#103-进度报告系统)
    - [10.4 智能折叠算法](#104-智能折叠算法)
    - [10.5 新增 flowsight-trace](#105-新增-crate-flowsight-trace)
    - [10.6 场景描述语言设计](#106-场景描述语言设计-flowsight-scenario-language) ⭐ 新增
    - [10.7 新增 flowsight-symbolic](#107-新增-crate-flowsight-symbolic) ⭐⭐ 核心
11. [风险评估与应对](#11-风险评估与应对-更新)
12. [资源估算](#12-资源估算)
13. [成功指标](#13-成功指标) ⭐ 新增
14. [扩展性设计](#14-扩展性设计) ⭐ 新增
    - [14.4 AI 集成设计](#144-ai-集成设计-v15) ⭐ 重要

---

## 🎯 核心理念：什么是真正的"执行流"

> ⚠️ **重要！这是 FlowSight 的核心价值，必须深刻理解！**

### 执行流 ≠ 简单的函数调用关系

**执行流 = 代码真正是怎么运行的，包括异步调用的完整时间线关系！**

### 示例1：insmod 和 probe 的关系

很多人以为 `insmod` 时就执行了 `probe`，其实并不是！

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    insmod my_driver.ko 执行流                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  用户空间: insmod my_driver.ko                                          │
│    │                                                                     │
│    └── 内核: sys_init_module()                                          │
│          └── load_module()                                              │
│                └── do_init_module()                                     │
│                      └── mod->init()                                    │
│                            └── my_init()           ← 用户的 init 函数  │
│                                  └── usb_register(&my_driver)          │
│                                        └── 注册到 USB 子系统           │
│                                              └── return 0              │
│                                                                          │
│  ══════════════════════════════════════════════════════════════════════ │
│  ↑ insmod 到这里就返回了！probe 还没执行！                              │
│  ══════════════════════════════════════════════════════════════════════ │
│                                                                          │
│                          ... 时间流逝 ...                                │
│                                                                          │
│  ══════════════════════════════════════════════════════════════════════ │
│  ↓ 某个时刻：USB 设备插入                                               │
│  ══════════════════════════════════════════════════════════════════════ │
│                                                                          │
│  硬件中断: USB 设备插入                                                  │
│    │                                                                     │
│    └── usb_hub_port_connect()                                           │
│          └── usb_new_device()                                           │
│                └── device_add()                                         │
│                      └── bus_probe_device()                             │
│                            └── __device_attach()                        │
│                                  └── driver_probe_device()              │
│                                        └── really_probe()               │
│                                              └── usb_probe_interface()  │
│                                                    └── drv->probe()     │
│                                                          │              │
│                                                          ▼              │
│                                                    my_probe()  ← 这才执行│
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 示例2：中断上半部和 WorkQueue 的时间线关系

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    中断处理 + WorkQueue 异步关系                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  时间线 ════════════════════════════════════════════════════════════▶   │
│                                                                          │
│  ┌─────────────────────┐                                                │
│  │ 硬中断上下文        │                                                │
│  │ (不可睡眠!)         │                                                │
│  └─────────────────────┘                                                │
│         │                                                                │
│         └── my_irq_handler()                                            │
│               │                                                          │
│               ├── 读取硬件状态 (快速操作)                                │
│               │                                                          │
│               ├── queue_work(wq, &dev->work)  ← 提交任务，立即返回！    │
│               │         │                                                │
│               │         └── 任务被放入队列，还没执行                    │
│               │                                                          │
│               └── return IRQ_HANDLED                                    │
│                                                                          │
│  ══════════════════════════════════════════════════════════════════════ │
│  ↑ 中断处理到这里就结束了！work handler 还没执行！                      │
│  ══════════════════════════════════════════════════════════════════════ │
│                                                                          │
│                    ... CPU 可能去做其他事情 ...                          │
│                                                                          │
│  ══════════════════════════════════════════════════════════════════════ │
│  ↓ 稍后：内核调度器调度 kworker 线程                                    │
│  ══════════════════════════════════════════════════════════════════════ │
│                                                                          │
│  ┌─────────────────────┐                                                │
│  │ 进程上下文          │                                                │
│  │ (可以睡眠)          │                                                │
│  └─────────────────────┘                                                │
│         │                                                                │
│         └── kworker/xxx 被调度                                          │
│               └── worker_thread()                                       │
│                     └── process_one_work()                              │
│                           └── work->func()                              │
│                                 │                                        │
│                                 ▼                                        │
│                           my_work_handler()  ← 这才真正执行耗时操作     │
│                                 │                                        │
│                                 ├── 可以调用 kmalloc(GFP_KERNEL)        │
│                                 ├── 可以睡眠等待                        │
│                                 └── 处理数据...                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 示例3：缺页中断的异步关系

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         缺页中断执行流                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  用户进程执行:                                                           │
│    │                                                                     │
│    └── ptr = malloc(4096);  ← 此时可能只分配了虚拟地址                  │
│          │                                                               │
│          └── *ptr = 123;    ← 第一次访问，触发缺页！                    │
│                │                                                         │
│  ══════════════════════════════════════════════════════════════════════ │
│  ↓ CPU 产生缺页异常，切换到内核                                         │
│  ══════════════════════════════════════════════════════════════════════ │
│                │                                                         │
│                └── do_page_fault()                                      │
│                      └── handle_mm_fault()                              │
│                            └── 分配物理页                               │
│                                  └── 建立页表映射                       │
│                                        └── 返回用户空间                 │
│                                                                          │
│  ══════════════════════════════════════════════════════════════════════ │
│  ↓ 用户进程被调度回来，继续执行                                         │
│  ══════════════════════════════════════════════════════════════════════ │
│                                              │                           │
│                                              └── *ptr = 123; ← 现在成功 │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 🎯 FlowSight 的核心价值

| 传统方式 | FlowSight |
|---------|-----------|
| 看代码猜测执行顺序 | **一目了然看到完整时间线** |
| 以为 insmod 就执行 probe | **清楚知道 probe 是设备插入时才触发** |
| 不知道 work handler 何时执行 | **看到中断返回后、调度器何时调度** |
| 要搭建 ftrace 才能验证 | **静态分析就能看到真正执行流** |
| 学习内核要读大量文档 | **IDE 直接展示运行机制** |

### 实现方式：纯静态分析架构（通用方案）

> ⚠️ **核心原则**：**不运行代码！纯粹通过阅读代码就能看懂执行流程！**
> 
> **目标**：让水平一般的人也能快速看懂十几万行代码的执行流程

### 人是怎么看懂代码的？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     人阅读代码的过程                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. 理解语法结构                                                        │
│     • 函数定义、变量声明、控制流                                        │
│                                                                          │
│  2. 追踪数据流                                                          │
│     • 这个变量从哪里来？                                                │
│     • 这个函数指针指向谁？                                              │
│                                                                          │
│  3. 识别模式                                                            │
│     • 这是 callback 模式                                                │
│     • 这是观察者模式                                                    │
│     • 这是事件循环                                                      │
│                                                                          │
│  4. 在脑中模拟执行                                                      │
│     • 如果这个条件为真，走这条路                                        │
│     • 这个 callback 会在 xxx 时候被调用                                 │
│                                                                          │
│  FlowSight 的目标：自动化这些过程！                                     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 纯静态分析技术栈

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    FlowSight 纯静态分析架构                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  源代码输入 (任意项目，任意语言)                                        │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  层次1：语法解析 (Parsing)                                       │    │
│  │  ═══════════════════════════                                     │    │
│  │  • Tree-sitter：快速、增量解析                                   │    │
│  │  • 构建 AST（抽象语法树）                                        │    │
│  │  • 支持多语言：C/C++/Java/Rust/Go/Python/JS...                  │    │
│  │                                                                  │    │
│  │  技术基础：编译原理 - 词法分析、语法分析                         │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  层次2：数据流分析 (Data Flow Analysis)                          │    │
│  │  ═════════════════════════════════════                           │    │
│  │  • 追踪变量的定义和使用 (def-use chain)                         │    │
│  │  • 追踪值的传播路径                                              │    │
│  │  • 常量传播、复制传播                                            │    │
│  │                                                                  │    │
│  │  技术基础：编译优化理论 - 活跃变量分析、到达定义分析             │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  层次3：⭐ 指针分析 (Pointer Analysis) - 核心！                   │    │
│  │  ══════════════════════════════════════════════                  │    │
│  │  问题：fp = some_func; fp(); ← fp 指向谁？                      │    │
│  │                                                                  │    │
│  │  算法：                                                          │    │
│  │  • Andersen 算法：精确，O(n³)                                   │    │
│  │  • Steensgaard 算法：快速，O(n)                                 │    │
│  │  • 上下文敏感分析：更精确                                        │    │
│  │                                                                  │    │
│  │  输出：每个函数指针可能指向的函数集合                            │    │
│  │  例：fp → {func_a, func_b}（两个可能的目标）                    │    │
│  │                                                                  │    │
│  │  技术基础：程序分析理论 - Points-to Analysis                    │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  层次4：⭐ 异步模式识别 (Async Pattern Recognition)              │    │
│  │  ══════════════════════════════════════════════════              │    │
│  │                                                                  │    │
│  │  通用模式识别（不依赖特定框架）：                                │    │
│  │  ─────────────────────────────────                               │    │
│  │  • Callback 模式：                                               │    │
│  │    - 函数指针作为参数传递                                        │    │
│  │    - 结构体中的函数指针字段被赋值                                │    │
│  │    - 识别"注册"和"触发"的对应关系                               │    │
│  │                                                                  │    │
│  │  • 事件循环模式：                                                │    │
│  │    - while(1) { get_event(); dispatch(); }                      │    │
│  │    - 识别 dispatch 表                                            │    │
│  │                                                                  │    │
│  │  • 队列模式：                                                    │    │
│  │    - enqueue(item) / dequeue() / process(item)                  │    │
│  │    - 识别生产者和消费者                                          │    │
│  │                                                                  │    │
│  │  • 信号/槽模式：                                                 │    │
│  │    - connect(signal, slot)                                       │    │
│  │    - emit(signal)                                                │    │
│  │                                                                  │    │
│  │  知识库增强（可选）：                                            │    │
│  │  ─────────────────────                                           │    │
│  │  • 已知框架的特定模式（Linux Kernel, Android, Qt...）           │    │
│  │  • 补充外部库的调用链信息                                        │    │
│  │                                                                  │    │
│  │  技术基础：设计模式识别、代码语义分析                            │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  层次5：⭐ 符号执行 (Symbolic Execution)                         │    │
│  │  ═════════════════════════════════════                           │    │
│  │                                                                  │    │
│  │  不实际运行代码，用符号代替具体值：                              │    │
│  │                                                                  │    │
│  │  if (x > 0) {           x = Symbol("x")                         │    │
│  │      call_a();    →     路径1: x > 0 → call_a()                 │    │
│  │  } else {               路径2: x ≤ 0 → call_b()                 │    │
│  │      call_b();                                                   │    │
│  │  }                                                               │    │
│  │                                                                  │    │
│  │  输出：所有可能的执行路径                                        │    │
│  │                                                                  │    │
│  │  技术基础：程序验证、软件测试                                    │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  层次6：⭐ AI 辅助推断 (可选，增强)                               │    │
│  │  ═════════════════════════════════                               │    │
│  │                                                                  │    │
│  │  当静态分析不确定时，AI 可以帮助：                               │    │
│  │  • 根据函数名/变量名推断意图                                     │    │
│  │  • 根据代码结构推断设计模式                                      │    │
│  │  • 生成自然语言解释                                              │    │
│  │                                                                  │    │
│  │  技术基础：代码大模型 (CodeLLM)                                  │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  输出：完整的执行流图                                            │    │
│  │  ═════════════════════                                           │    │
│  │  • 函数调用关系（包括间接调用）                                  │    │
│  │  • 异步触发关系（callback 何时被调用）                          │    │
│  │  • 可能的执行路径                                                │    │
│  │  • 置信度标注（确定 vs 推断）                                    │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 通用异步模式识别（不依赖特定框架）

| 模式 | 识别方法 | 示例 |
|------|----------|------|
| **Callback** | 函数指针赋值 + 后续调用 | `obj->cb = my_func; ... obj->cb()` |
| **事件循环** | while + dispatch 表 | `while(1) handlers[event]()` |
| **队列** | enqueue/dequeue 配对 | `push(work); pop()->func()` |
| **信号/槽** | connect + emit | `connect(sig, slot); emit(sig)` |
| **状态机** | switch/case + 状态变量 | `switch(state) case X: goto Y;` |

### 处理未知项目的策略

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    处理任意新项目的策略                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  第一层：纯代码分析（100% 通用）                                        │
│  ═══════════════════════════════                                        │
│  • 直接调用：main() → init() → run()  ✅ 确定                          │
│  • 间接调用：通过指针分析确定目标                                       │
│  • 异步模式：通过模式识别确定 callback 关系                            │
│                                                                          │
│  第二层：用户辅助学习                                                   │
│  ═══════════════════════                                                │
│  当分析不确定时，IDE 可以：                                             │
│  • 询问用户："这个函数指针可能指向哪个函数？"                          │
│  • 用户选择后，IDE 学习并记住                                           │
│  • 下次自动应用                                                         │
│                                                                          │
│  第三层：知识库增强（可选）                                             │
│  ═══════════════════════════                                            │
│  • 对于常见框架，使用预置知识库                                         │
│  • 知识库可以由社区贡献和共享                                           │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 为什么这个方案可行？

1. **编译原理成熟**：语法分析、数据流分析都是成熟技术
2. **指针分析有解**：Andersen 等算法已经被广泛使用
3. **模式是通用的**：callback、事件循环等模式在所有语言中都存在
4. **AI 可以补充**：当传统分析不确定时，AI 可以推断

**核心：人能看懂的代码，机器也能通过相同的分析过程看懂！**

### 技术实现架构 (已实现)

```rust
// flowsight-knowledge 知识库核心数据结构

/// 调用链节点 - 记录每一步调用
pub struct CallChainNode {
    pub function: String,           // 函数名
    pub file: Option<String>,       // 内核源码路径
    pub context: ExecutionContext,  // 执行上下文
    pub description: Option<String>,// 说明
    pub is_user_entry: bool,        // 是否是用户代码入口
}

/// 完整调用链 - 从触发源到用户代码
pub struct CallChain {
    pub name: String,               // 如 "USB probe 调用链"
    pub trigger_source: String,     // 如 "USB 设备插入"
    pub nodes: Vec<CallChainNode>,  // 完整调用路径
}

/// 异步时间线 - 展示两条执行流的关系
pub struct AsyncTimeline {
    pub phase1: TimelinePhase,      // 第一阶段 (如中断上半部)
    pub separation: String,         // 分割说明
    pub phase2: TimelinePhase,      // 第二阶段 (如 WorkQueue)
}
```

### 已内置的调用链

| 子系统 | 回调 | 调用链深度 | 状态 |
|--------|------|-----------|------|
| USB Driver | probe | 9 层 | ✅ 已实现 |
| USB Driver | disconnect | 6 层 | ✅ 已实现 |
| file_operations | open | 6 层 | ✅ 已实现 |
| WorkQueue | work handler | 5 层 | ✅ 已实现 |
| Timer | timer callback | 5 层 | ✅ 已实现 |
| Interrupt | IRQ handler | 3 层 | ✅ 已实现 |

### 关键 API

```rust
// 获取框架回调的完整内核调用链
kb.get_callback_call_chain("usb_driver", "probe")

// 获取异步模式的 handler 调用链
kb.get_async_handler_chain("work_struct")

// 获取异步模式的时间线关系
kb.get_async_timeline("work_struct")
```

### 下一步：在 UI 中展示

分析引擎检测到用户代码 → 匹配知识库模式 → 注入内核调用链 → UI 展示完整时间线

---

## 🎯 核心开发策略

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         开发策略：先落地，再扩展                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   第一阶段：IDE 落地 (v1.0)                                              │
│   ══════════════════════════                                             │
│   • 知识库：只支持 Linux 内核                                            │
│   • 平台：Windows 优先 → Linux → macOS                                  │
│   • 语言：简体中文 + 英文 (首发双语支持)                                 │
│   • 目标：把 IDE 完整落地、调试稳定、发布正式版                          │
│                                                                          │
│   第二阶段：知识扩展 (v2.0+)                                             │
│   ══════════════════════════                                             │
│   • IDE 稳定后，逐步添加 Android 知识库                                  │
│   • 再逐步添加其他语言和平台                                             │
│   • 稳扎稳打，每步充分测试                                               │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  v0.1 → v0.5 → v1.0          v1.5 → v2.0          v2.5 → v3.0   │   │
│   │   │       │       │            │       │            │       │    │   │
│   │   └───────┴───────┘            └───────┘            └───────┘    │   │
│   │    Linux 内核 + IDE             Android              其他        │   │
│   │    ════════════════             ════════             ════        │   │
│   │     当前阶段重点                 下一阶段             远期        │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 1. 项目愿景

### 1.1 问题陈述

当开发者面对 Linux 内核这样的超大型代码库（2000万+ 行）时，现有工具存在严重不足：

| 现有工具 | 能做什么 | 做不到什么 |
|----------|----------|------------|
| VS Code + clangd | 符号跳转、补全 | 看不到异步执行流、函数指针指向 |
| Source Insight | 符号索引、调用图 | 不理解内核异步机制 |
| Understand | 静态分析、度量 | 无法追踪回调绑定 |
| Sourcetrail | 可视化调用图 | 已停止维护，不理解语义 |

**核心痛点**：当代码出现以下模式时，所有 IDE 都"迷路"了：

```c
// 😵 现有 IDE 看到这里就断了
INIT_WORK(&dev->work, my_handler);    // 绑定
schedule_work(&dev->work);             // 触发 → ??? 谁被调用？

request_irq(irq, irq_handler, ...);    // 注册 → ??? 何时执行？

static struct file_operations fops = {
    .read = my_read,                    // 赋值 → ??? 谁调用 .read？
};
```

### 1.2 解决方案

**FlowSight** —— 一个能"看懂"代码执行流的 IDE：

- 🔍 **静态分析** = 不需要运行代码，纯代码阅读
- 🧠 **语义理解** = 理解异步机制、回调模式、函数指针
- 📊 **可视化** = 看到完整的执行流程图
- ⏱️ **动态结合** = 允许导入运行时 Trace 数据进行验证
- 🖥️ **跨平台** = Windows (首要) / Linux / macOS

### 1.3 目标用户

| 用户群体 | 使用场景 |
|----------|----------|
| Linux 内核开发者 | 理解子系统、审查补丁 |
| 驱动开发者 | 学习驱动框架、调试问题 |
| **Android 系统开发者** | 理解 Framework、追踪 Binder 调用 |
| **Android App 开发者** | 分析复杂的回调和协程流程 |
| 安全研究员 | 漏洞分析、攻击面评估 |
| 嵌入式开发者 | 理解 BSP、定制内核 |
| 学生/教育者 | 学习操作系统原理 |

---

## 2. 核心价值主张

### 2.1 差异化功能

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      FlowSight 核心功能矩阵                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   功能                          VS Code    Source Insight   FlowSight       │
│   ─────────────────────────────────────────────────────────────────────────  │
│   基础代码编辑                    ✅           ✅              ✅            │
│   符号跳转 (LSP)                  ✅           ✅              ✅            │
│   函数调用图                      ⚠️           ✅              ✅ (交互式)   │
│   ─────────────────────────────────────────────────────────────────────────  │
│   ⭐ 场景化数据流分析              ❌           ❌              ✅ 核心      │
│   ⭐ 指定参数看变量值              ❌           ❌              ✅ 核心      │
│   ⭐ 实时高亮执行路径              ❌           ❌              ✅ 核心      │
│   ─────────────────────────────────────────────────────────────────────────  │
│   异步执行流可视化                ❌           ❌              ✅ 核心       │
│   函数指针解析                    ❌           ⚠️              ✅ 核心       │
│   运行时 Trace 导入               ❌           ❌              ✅ 独有       │
│   Kconfig/DTS 解析                ❌           ❌              ✅ 独有       │
│   ─────────────────────────────────────────────────────────────────────────  │
│   内核框架知识库                  ❌           ❌              ✅            │
│   智能文档生成                    ❌           ❌              ✅            │
│   数据结构生命周期                ❌           ❌              ✅            │
│   ─────────────────────────────────────────────────────────────────────────  │
│   AI 代码理解                     ❌           ❌              ✅ v1.5       │
│   Android Binder 追踪             ❌           ❌              ✅ v2.0       │
│   JNI 跨语言分析                  ❌           ❌              ✅ v2.0       │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心竞争力：场景化数据流分析

> **不运行代码，就能看到代码在特定输入下的行为**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      场景化数据流分析示例                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   用户操作:                                                                  │
│   1. 打开 usb_probe() 函数                                                  │
│   2. 右键 → "创建分析场景"                                                  │
│   3. 填写: id->idVendor = 0x1234, id->idProduct = 0x5678                   │
│   4. 点击 "分析"                                                            │
│                                                                              │
│   FlowSight 显示:                                                           │
│   ┌──────────────────────────────────────────────────────────────────────┐  │
│   │  执行流图                                   │  代码编辑器             │  │
│   │                                             │                        │  │
│   │  ┌─────────────────┐                       │  58 │ usb_probe(...)   │  │
│   │  │ usb_probe()     │                       │     │ // idVendor=0x1234│  │
│   │  │ idVendor=0x1234 │                       │  60 │ dev->type = ...   │  │
│   │  └────────┬────────┘                       │     │ // type = 0x56   │  │
│   │           ▼                                │  62 │ if (type == 0x56) │  │
│   │  ┌─────────────────┐                       │     │ // ✅ 条件满足    │  │
│   │  │ dev->type=0x56  │                       │  63 │   init_type_a()   │  │
│   │  └────────┬────────┘                       │     │ // ← 将执行       │  │
│   │      ┌────┴────┐                           │  64 │ else              │  │
│   │      ▼         ▼                           │     │ // ❌ 不执行      │  │
│   │  ┌───────┐ ┌───────┐                       │  65 │   init_type_b()   │  │
│   │  │✅ A   │ │❌ B   │                       │     │ // (灰显)         │  │
│   │  └───────┘ └───────┘                       │                        │  │
│   └──────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│   价值: 不用调试器，就能看到代码在特定输入下的完整行为！                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 用户故事

**故事1：理解 USB 热插拔流程**

> 作为内核开发者，我想看到当 USB 设备插入时，从 hub_irq() 中断到我的驱动 probe() 
> 被调用的完整流程，包括中间经过的工作队列、tasklet。我希望能在图上折叠掉我不关心的内核锁机制代码。

**故事2：追踪内存分配**

> 作为安全研究员，我想看到 kmalloc() 分配的内存在哪些函数中被使用，
> 最终在哪里被释放，并且我导入了一份 ftrace 日志，想在代码中高亮显示实际执行过的路径。

**故事3：编写新驱动**

> 作为驱动开发者，我写完了一个 I2C 驱动，想一键生成一份包含调用流程图和结构体关系图的 Markdown 文档，
> 以便向团队汇报。

---

## 3. 技术架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                             FlowSight                                        │
│                              整体架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           表现层 (Presentation)                         │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │                      Tauri 桌面应用                              │   │ │
│  │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐       │   │ │
│  │  │  │  编辑器   │ │  项目    │ │  流程图   │ │  知识库   │       │   │ │
│  │  │  │  Monaco   │ │  管理器  │ │  D3/React │ │  编辑器   │       │   │ │
│  │  │  └───────────┘ └───────────┘ └───────────┘ └───────────┘       │   │ │
│  │  │                      React + TypeScript                         │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     │ Tauri IPC / Commands                   │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           应用层 (Application)                          │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │ │
│  │  │   项目      │ │   查询     │ │   LSP     │ │   配置      │      │ │
│  │  │   服务      │ │   服务     │ │   客户端    │ │   管理      │      │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘      │ │
│  │                           Rust (Tauri Backend)                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           核心层 (Core)                                 │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐ │ │
│  │  │                       分析引擎 (flowsight-core)                         │ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    │ │ │
│  │  │  │ 解析器  │ │ 索引器  │ │ 类型    │ │ 调用图  │ │ 异步    │    │ │ │
│  │  │  │ Parser  │ │ Indexer │ │ System  │ │ Builder │ │ Tracker │    │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘    │ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐                │ │ │
│  │  │  │ 函数    │ │ Kconfig │ │ 知识库  │ │ Trace   │                │ │ │
│  │  │  │ 指针    │ │ /DTS    │ │ 引擎    │ │ Importer│                │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘                │ │ │
│  │  └───────────────────────────────────────────────────────────────────┘ │ │
│  │                              Rust                                       │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                          基础层 (Infrastructure)                        │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │ │
│  │  │ tree-sitter │ │  LSP/Clang  │ │   SQLite    │ │   sled      │      │ │
│  │  │ (快速解析)  │ │ (精确语义)  │ │  (符号表)   │ │  (调用图)   │      │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘      │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 核心模块设计增强

#### 3.2.1 混合解析引擎 (Hybrid Parser)

*   **Tree-sitter**: 负责快速的语法高亮、大纲提取和初步的模式匹配。
*   **LSP 集成 (clangd)**: 负责精确的"跳转到定义"、"查找引用"、宏展开。我们不重复造轮子，而是利用成熟的 LSP 生态。
*   **Kconfig/DTS 解析**: 专门的模块解析内核配置文件 `.config` 和设备树 `.dts`，用于剔除未编译代码和关联硬件信息。

#### 3.2.2 动态 Trace 集成

*   **Importer**: 支持导入 `ftrace` (text/binary), `systrace`, `perf.data` 等格式。
*   **Mapper**: 将 Trace 中的函数地址/符号映射回源码位置。
*   **Visualizer**: 在静态调用图上叠加"热力图"或高亮路径，显示实际执行流。

#### 3.2.3 知识库编辑器

*   **GUI Editor**: 内置工具，允许用户通过 UI 操作创建新的匹配规则。
    *   例如：选中代码 -> 右键 "标记为异步触发点" -> 填写参数 -> 生成 YAML。

---

## 4. 技术选型

### 4.1 技术栈总览

| 层次 | 技术 | 理由 |
|------|------|------|
| **桌面框架** | Tauri 2.0 | 高性能、小体积、Rust 后端 |
| **前端框架** | React 18 + TS | 生态成熟、组件丰富 |
| **代码编辑器** | Monaco Editor | VS Code 同款，功能完整 |
| **LSP 客户端** | monaco-languageclient | 连接 clangd/rust-analyzer |
| **执行流可视化** | React Flow | 交互式图谱，开发效率高 |
| **终端** | xterm.js | 成熟的 Web 终端实现 |
| **核心引擎** | Rust | 内存安全、高性能 |
| **解析** | tree-sitter + clangd | 速度与精度的平衡 |
| **存储** | SQLite + sled | 关系型与图数据的结合 |
| **AI 后端** | Ollama / OpenAI API | 本地+云端双支持 |

### 4.2 为什么我们能做好完整 IDE？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FlowSight IDE 技术优势                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   不需要从零开始！我们站在巨人肩膀上：                                       │
│                                                                              │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐               │
│   │ Monaco Editor  │  │ clangd LSP     │  │ React Flow     │               │
│   │ (VS Code 核心) │  │ (智能补全)     │  │ (交互式图谱)   │               │
│   │                │  │                │  │                │               │
│   │ • 代码编辑     │  │ • 自动补全     │  │ • 拖拽缩放     │               │
│   │ • 语法高亮     │  │ • 跳转定义     │  │ • 节点连线     │               │
│   │ • 多光标       │  │ • 错误诊断     │  │ • 布局算法     │               │
│   │ • Code Lens    │  │ • 悬停文档     │  │ • 自定义节点   │               │
│   └────────────────┘  └────────────────┘  └────────────────┘               │
│           │                  │                  │                           │
│           └──────────────────┼──────────────────┘                           │
│                              ▼                                               │
│   ┌──────────────────────────────────────────────────────────────────────┐  │
│   │                      FlowSight 核心引擎                               │  │
│   │                                                                       │  │
│   │   我们只需要专注于：                                                  │  │
│   │   ⭐ 异步执行流分析                                                   │  │
│   │   ⭐ 函数指针解析                                                     │  │
│   │   ⭐ 知识库驱动的模式识别                                             │  │
│   │   ⭐ 实时增量分析                                                     │  │
│   │   ⭐ AI 代码理解                                                      │  │
│   │                                                                       │  │
│   └──────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. 详细开发计划

### 5.1 总体时间线

```
2026                                              2027
Q1        Q2        Q3        Q4        Q1        Q2        Q3
│         │         │         │         │         │         │
▼         ▼         ▼         ▼         ▼         ▼         ▼
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│  P0     │   P1    │   P2    │   P3    │   P4    │   P5    │   P6    │
│ 原型    │  核心   │  IDE    │  Trace  │  AI     │  测试   │  生态   │
│ 验证    │  引擎   │  交互   │  集成   │  集成   │  发布   │  建设   │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
   MVP       Alpha     Beta              RC        v1.0      v1.5+
                                                  (稳定版)  (AI版)
```

### 5.1.1 📍 当前状态总览 (2026-01-07 重新评估)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      📊 v1.0 发布目标 (macOS 首发)                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   🎯 核心目标: 让 Linux 内核/驱动开发者真正用起来                            │
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  ⭐⭐⭐ 场景化数据流分析 (核心差异化功能)                             │   │
│   │  ─────────────────────────────────────────                           │   │
│   │  用户指定参数值 → 看到每个变量的值 → 高亮实际执行路径               │   │
│   │                                                                      │   │
│   │  [x] 场景输入 UI (ScenarioPanel)              ✅ 已完成              │   │
│   │  [x] 结果展示 UI (ScenarioResults)            ✅ 已完成              │   │
│   │  [ ] ⭐ 表达式求值器 (evaluator)              🔴 核心待做            │   │
│   │  [ ] ⭐ 常量传播分析                          🔴 核心待做            │   │
│   │  [ ] ⭐ 条件分支判定                          🔴 核心待做            │   │
│   │  [ ] ⭐ 执行流图显示变量值                    🔴 核心待做            │   │
│   │  [ ] ⭐ 高亮实际路径/灰显不走分支             🔴 核心待做            │   │
│   │  [ ] 场景保存/加载                            🟡 重要                │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   已完成的基础功能:                                                          │
│   ├─ IDE 基础 (编辑器/标签页/设置/查找)    [████████████████████] 100% ✅   │
│   ├─ 执行流基础可视化                      [████████████████████] 100% ✅   │
│   ├─ 异步追踪 + 函数指针解析               [████████████████████] 100% ✅   │
│   └─ 调用者分析 + CLI                      [████████████████████] 100% ✅   │
│                                                                              │
│   v1.0 延后的功能:                                                           │
│   ├─ 终端集成、Git 集成                                                      │
│   ├─ AI 集成                                                                 │
│   ├─ Trace 导入                                                              │
│   └─ 多语言支持                                                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 🔴 v1.0 发布前必须完成的核心功能

| 优先级 | 功能 | 说明 | 预计工时 |
|--------|------|------|----------|
| ⭐⭐⭐ | **表达式求值器** | 支持 C 语言表达式计算 (算术/位运算/逻辑) | 4h |
| ⭐⭐⭐ | **常量传播** | 跟踪变量值在代码中的传播 | 4h |
| ⭐⭐⭐ | **条件分支判定** | 根据变量值判断走哪个分支 | 3h |
| ⭐⭐⭐ | **流图显示变量值** | 每个节点显示当前变量状态 | 3h |
| ⭐⭐⭐ | **路径高亮** | 高亮实际路径，灰显不可达分支 | 2h |
| ⭐⭐ | **场景保存/加载** | 保存场景配置到文件 | 2h |
| ⭐⭐ | **真实驱动测试** | 用 USB/I2C 驱动验证功能 | 4h |

**✅ 刚完成的功能** (2026-01-07 更新):

| 序号 | 任务 | 状态 | 说明 |
|------|------|------|------|
| 1 | **欢迎页面** | ✅ | 启动时显示，快速入门指南 |
| 2 | **状态栏** | ✅ | 显示分析状态、函数数量、版本 |
| 3 | **多标签页编辑** | ✅ | 可同时打开多文件，拖拽排序 |
| 4 | **文件保存** | ✅ | Ctrl+S 保存，未保存提示 |
| 5 | **面包屑导航** | ✅ | 显示文件路径和当前函数 |
| 6 | **子树聚焦** | ✅ | 右键菜单 "只看此分支" |
| 7 | **按深度折叠** | ✅ | 层级选择器 (1-5) + 快捷键 |
| 8 | **GitHub Actions** | ✅ | 自动构建 Windows/macOS/Linux |
| 9 | 执行流多视图 | ✅ | 图形/ftrace/树形 切换 |
| 10 | ftrace 格式优化 | ✅ | 行号 + 内核API标记 |
| 11 | **设置面板** | ✅ | 自动保存、字体、主题等配置 |
| 12 | **查找替换** | ✅ | Ctrl+F/H，支持正则表达式 |
| 13 | **快捷键帮助** | ✅ | 按 ? 显示所有快捷键 |
| 14 | **最近文件** | ✅ | 欢迎页显示最近打开的文件 |
| 15 | **跳转行号** | ✅ | Ctrl+G 快速跳转到指定行 |
| 16 | **关闭标签** | ✅ | Ctrl+W 关闭当前标签页 |
| 17 | **自动保存** | ✅ | 2秒延迟自动保存 (可配置) |
| 18 | 导出功能 | ✅ | 纯文本/Markdown/JSON |
| 19 | 帮助文档弹窗 | ✅ | 格式说明 + 标记含义 |
| 20 | **浅色主题** | ✅ | 完整浅色主题支持 |
| 21 | **单词高亮** | ✅ | 选中单词高亮所有匹配 |
| 22 | **缩放控制** | ✅ | 执行流图缩放百分比显示 |
| 23 | **PNG导出** | ✅ | 执行流图导出为图片 |
| 24 | **全屏模式** | ✅ | 执行流图全屏显示 |
| 25 | **节点提示** | ✅ | 悬停显示详细信息 |
| 26 | **文件统计** | ✅ | 状态栏显示行数/字符数 |
| 27 | **Toast通知** | ✅ | 操作反馈提示 (保存等) |
| 28 | **拖放文件** | ✅ | 拖放文件到窗口直接打开 |
| 29 | **关于对话框** | ✅ | 显示版本信息和链接 |
| 30 | **确认对话框** | ✅ | 关闭未保存标签时提示 |
| 31 | **通用组件** | ✅ | LoadingSpinner, ContextMenu |
| 32 | **快速打开** | ✅ | Ctrl+E 打开最近文件列表 |
| 33 | **差异视图** | ✅ | DiffView 组件 (待集成) |
| 34 | **空状态** | ✅ | EmptyState 组件 |

### ⭐ 核心亮点功能

| 序号 | 功能 | 状态 | 说明 |
|------|------|------|------|
| 1 | **异步边颜色区分** | ✅ | WorkQueue(橙), Timer(绿), IRQ(红), Tasklet(紫) |
| 2 | **异步标签颜色** | ✅ | 不同机制不同颜色，一目了然 |
| 3 | **执行上下文提示** | ✅ | tooltip显示是否可睡眠 |
| 4 | **异步机制图例** | ✅ | 工具栏显示颜色说明 |
| 5 | **回调绑定信息** | ✅ | 点击回调函数显示绑定来源 |
| 6 | **睡眠状态标注** | ✅ | 标注进程/中断/软中断上下文 |
| 7 | **场景化数据流** | ✅ | ⭐⭐ 核心！参数绑定+变量追踪 |
| 8 | **场景执行引擎** | ✅ | 后端符号执行，显示每步变量值 |
| 9 | **场景结果展示** | ✅ | 执行时间线+变量表格+JSON导出 |
| 10 | **调用者分析** | ✅ | 显示谁调用了函数+二级展开 |

**✅ 之前完成的 UI/UX 改进**:

| 序号 | 任务 | 状态 | 说明 |
|------|------|------|------|
| 1 | 历史导航 (后退/前进) | ✅ | ◀ ▶ 按钮 + Alt+←/→ + 鼠标侧键 |
| 2 | 隐藏内核API开关 | ✅ | 100+ 内核函数过滤 |
| 3 | 代码→图联动 | ✅ | 光标自动高亮对应节点 |
| 4 | 命令面板 (Ctrl+P) | ✅ | 模糊搜索文件/符号 |

**🎯 下一步工作重点**:
- LSP 集成 (clangd) - 智能补全、跳转定义
- 多标签页编辑
- CLI trace 命令增强 (可选)
- Phase 0 测试框架补充

**📅 延后任务**:
- LSP 集成 (clangd) → v1.1

**✅ 已完成** (2026-01-07):
- 多标签页编辑
- 面包屑导航
- 按深度折叠 (1-5 层)
- 子树聚焦 (右键菜单)
- 文件保存 (Ctrl+S)

---

### 5.1.2 ⭐ 执行流多视图 + CLI 交互 (高优先级)

> 基于用户反馈：程序员更喜欢 ftrace 风格的文本输出

**功能概述**：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        执行流多视图架构                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   用户输入: 函数名 (e.g. "async_demo_init")                                  │
│                       │                                                      │
│                       ▼                                                      │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    FlowSight 分析引擎                                │   │
│   │            (生成统一的 FlowTree 数据结构)                            │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                       │                                                      │
│         ┌─────────────┼─────────────┬─────────────┐                         │
│         ▼             ▼             ▼             ▼                         │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐                   │
│   │ 图形视图  │  │ ftrace   │  │ 缩进文本  │  │ Markdown │                   │
│   │ (React   │  │ 风格视图  │  │ 树形视图  │  │ 导出     │                   │
│   │  Flow)   │  │          │  │          │  │          │                   │
│   └──────────┘  └──────────┘  └──────────┘  └──────────┘                   │
│        │              │             │             │                         │
│        └──────────────┴─────────────┴─────────────┘                         │
│                       │                                                      │
│         ┌─────────────┴─────────────┐                                       │
│         ▼                           ▼                                       │
│   ┌──────────────┐          ┌──────────────┐                                │
│   │   UI 界面    │          │   CLI 终端   │                                │
│   │  (Tauri)     │          │ (flowsight)  │                                │
│   └──────────────┘          └──────────────┘                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**1. 多视图模式 (UI 内切换)**

| 视图模式 | 描述 | 使用场景 |
|----------|------|----------|
| 📊 图形 (当前) | React Flow 交互式图谱 | 浏览复杂调用关系 |
| 📝 ftrace | 类似 ftrace 的缩进文本 | 内核开发者习惯 |
| 🌲 树形 | 简洁的缩进树 | 快速浏览 |
| 📋 列表 | 平铺调用链 | 搜索特定函数 |

**ftrace 风格示例**:
```
 0)               |  async_demo_init() {
 0)               |    platform_driver_register() {
 0)   ........    |      __platform_driver_register();
 0)               |    }
 0)               |    INIT_WORK() {           /* 异步 */
 0)   --------    |      → demo_work_handler   /* WorkQueue */
 0)               |    }
 0)               |    setup_timer() {         /* 异步 */
 0)   --------    |      → demo_timer_callback /* Timer */
 0)               |    }
 0)               |  }
```

**2. 导出功能**

| 格式 | 描述 |
|------|------|
| Markdown | 带代码块的文档，可嵌入 README |
| 纯文本 | ftrace 风格，可粘贴到邮件/聊天 |
| JSON | 机器可读，供其他工具使用 |
| SVG | 图形导出为图片 |

**3. CLI 交互模式**

```bash
# 查询单个函数的执行流
$ flowsight trace async_demo_init
 0)               |  async_demo_init() {
 0)               |    platform_driver_register();
 0)               |    INIT_WORK() → demo_work_handler [WorkQueue]
 0)               |    setup_timer() → demo_timer_callback [Timer]
 0)               |  }

# 查询谁调用了某函数
$ flowsight callers demo_work_handler
Called by:
  → async_demo_init() via WorkQueue (INIT_WORK)
  → async_demo_probe() via schedule_work()

# 查询某函数调用了谁
$ flowsight callees async_demo_init
async_demo_init() calls:
  ├── platform_driver_register() [Direct]
  ├── INIT_WORK() [Async → demo_work_handler]
  ├── setup_timer() [Async → demo_timer_callback]
  └── pr_info() [Direct]

# 导出 Markdown
$ flowsight trace async_demo_init --format markdown > flow.md

# 交互模式
$ flowsight -i
flowsight> trace async_demo_init
...
flowsight> callers demo_work_handler
...
flowsight> exit
```

**4. 实现计划**

| 序号 | 任务 | 预估时间 | 优先级 |
|------|------|----------|--------|
| 1 | **ftrace 格式渲染器** | 2h | ⭐⭐⭐ |
| 2 | **视图切换 UI** (工具栏按钮) | 1h | ⭐⭐⭐ |
| 3 | **Markdown 导出** | 2h | ⭐⭐⭐ |
| 4 | **纯文本/JSON 导出** | 1h | ⭐⭐ |
| 5 | **CLI trace 命令** | 3h | ⭐⭐ |
| 6 | **CLI callers/callees** | 2h | ⭐⭐ |
| 7 | **CLI 交互模式** | 3h | ⭐ |
| 8 | **SVG 图片导出** | 2h | ⭐ |

**状态** (2026-01-07 更新): 
- [x] ftrace 格式渲染器 ✅
- [x] 视图切换 UI ✅
- [x] Markdown 导出 ✅
- [x] 帮助文档弹窗 ✅
- [x] CLI trace 命令 ✅ - ftrace/markdown/json 格式输出
- [x] CLI callers 命令 ✅ - 显示调用者
- [x] CLI callees 命令 ✅ - 显示被调用者

---

### 5.2 Phase 0: 原型验证 (8 周) ✅ 基本完成

**目标**: 验证核心技术可行性

**状态**: 核心功能已完成，测试框架延后

*   [x] 项目仓库初始化
*   [x] Rust workspace 结构
*   [x] tree-sitter-c 集成与 AST 遍历
*   [x] 异步模式匹配原型 (work_struct)
*   [x] 简单 UI 原型 (Tauri + React Flow)
*   [~] **基础测试框架** — 🔜 *延后到 Phase 2 UI 稳定后再补充*

### 5.3 Phase 1: 核心引擎增强 (12 周)

**目标**: 完成分析引擎核心功能，解决大型项目支持问题

#### 5.3.1 基础架构层 (关键！影响后续所有功能)

*   **增量解析引擎**:
    *   [x] 改造 TreeSitterParser，保存 Tree 用于增量更新
    *   [ ] 实现 `IncrementalParser` trait，支持局部代码变更
    *   [x] 实现 `TreeCache`，缓存已解析的语法树
*   **增量索引系统**:
    *   [ ] 数据库添加 `files` 表，记录文件 hash/mtime
    *   [x] 实现 `FileVersionTracker`，检测需要重新索引的文件
    *   [x] 实现 `BatchIndexer`，批量插入优化（事务 + 预编译语句）
    *   [ ] 支持局部更新：修改代码后只重新分析变更的函数
*   **并行处理**:
    *   [ ] 使用 rayon 并行解析多文件
    *   [ ] 并行构建索引

#### 5.3.2 大型项目支持 (2000万+ 行代码)

*   **内存管理**:
    *   [ ] 实现 LRU 缓存策略，限制内存中的 Tree 数量
    *   [ ] 按需加载：只加载当前编辑文件 + 相关文件
    *   [ ] 实现文件分片：超大文件分块解析
*   **性能优化**:
    *   [ ] 首次索引后保存到磁盘，下次启动直接加载
    *   [ ] 后台线程持续索引，不阻塞 UI
    *   [ ] 实现索引优先级：用户打开的文件优先索引

#### 5.3.3 进度报告系统

*   **后端**:
    *   [ ] 定义 `ProgressEvent` 结构 (phase, current, total, message)
    *   [ ] 在解析/索引过程中发送进度事件
    *   [ ] 通过 Tauri Events 推送到前端
*   **前端**:
    *   [x] 实现 `ProgressIndicator` 组件
    *   [ ] 显示索引进度 (文件数/总数)
    *   [ ] 显示当前阶段 (解析中/分析中/索引中)
    *   [ ] 支持取消操作

#### 5.3.4 分析能力增强

*   **LSP 集成**: 实现与 `clangd` 的通信，获取精确符号信息
*   **Kconfig 解析**: 读取 `.config` 文件，构建条件编译上下文
*   [x] **高级异步追踪**: 支持 timer, tasklet, irq 等 15+ 种模式
*   [x] **函数指针解析**: 实现基于 ops 表和变量赋值的解析算法
*   **完整 Linux 内核模式识别**:
    *   [x] 覆盖所有常见异步机制 (work, timer, tasklet, softirq, kthread, rcu)
    *   [x] 覆盖驱动框架 (USB, PCI, I2C, SPI, Platform, Block, Net)
    *   [ ] 覆盖文件系统 VFS 回调
    *   [ ] 覆盖网络子系统回调

#### 5.3.5 ⭐⭐⭐ 核心：纯静态分析引擎 (v1.0 必须完成)

> **参考文档**：`docs/architecture/STATIC-ANALYSIS-DESIGN.md`
>
> **核心目标**：不运行代码，纯粹通过阅读源代码，自动分析出函数的真实执行流程。

##### 5.3.5.1 类型分析 (Type Analysis)

*   [ ] **识别函数指针类型**
    *   解析 typedef：`typedef void (*callback_t)(int);`
    *   解析结构体字段：`struct ops { int (*open)(void); };`
    *   解析函数参数：`void register_cb(void (*cb)(void));`
*   [ ] **构建函数指针类型数据库**
    *   记录每个函数指针类型的签名
    *   记录哪些函数可以赋值给该类型

##### 5.3.5.2 指针分析 (Pointer Analysis) — 核心！

> **技术基础**：Andersen 算法、约束求解

*   [ ] **收集约束**
    *   `fp = func`：AddressOf 约束
    *   `fp = gp`：Copy 约束
    *   `fp = *pp`：Load 约束
    *   `*pp = fp`：Store 约束
*   [ ] **实现 Andersen 求解器**
    *   迭代传播约束直到不动点
    *   输出：每个指针变量的 points-to 集合
    *   例：`pts(fp) = {func_a, func_b}`
*   [ ] **结构体字段分析**
    *   追踪 `obj->callback = handler`
    *   区分不同实例（allocation site）
*   [ ] **数组分析**
    *   `handlers[i] = func` → 数组元素可能指向 func
    *   `handlers[x]()` → 可能调用数组中任意元素
*   [ ] **性能优化**
    *   对大型项目，可降级到 Steensgaard 算法 O(n)
    *   增量分析：代码修改后只更新受影响部分

##### 5.3.5.3 通用异步模式识别 (Generic Async Pattern Recognition)

> **核心思想**：不依赖特定框架，通过分析代码结构识别异步关系

*   [ ] **模式1：简单 Callback**
    ```c
    obj->callback = handler;  // 绑定
    ...
    obj->callback(args);      // 调用
    ```
    *   识别：结构体字段是函数指针类型
    *   追踪：该字段的赋值和调用

*   [ ] **模式2：注册函数**
    ```c
    register_xxx(handler);    // 注册
    // handler 会在某个条件下被调用
    ```
    *   识别：函数参数是函数指针类型
    *   追踪：注册函数内部如何存储和调用 callback

*   [ ] **模式3：事件循环**
    ```c
    while (1) {
        event = get_event();
        handlers[event.type](event);
    }
    ```
    *   识别：无限循环 + 数组/表索引调用
    *   追踪：handlers 数组的赋值

*   [ ] **模式4：队列模式**
    ```c
    enqueue(queue, work);     // 入队
    work = dequeue(queue);    // 出队
    work->func();             // 执行
    ```
    *   识别：队列操作函数
    *   追踪：队列元素的流动

*   [ ] **模式5：信号/槽模式**
    ```c
    connect(signal, slot);    // 连接
    emit(signal);             // 发射
    ```
    *   识别：connect/on/bind 类函数
    *   追踪：signal → slot 映射

##### 5.3.5.4 结果分类系统（100% 准确目标）

> **核心原则：技术是严谨的，不可以猜！宁可说"不确定"，也不给错误信息！**

*   [ ] **三种结果类型**
    *   **Certain (确定)**：100% 正确
        *   直接调用、确定的赋值、已知框架
    *   **Possible (可能)**：列出所有可能，100% 完整不遗漏
        *   条件赋值、数组索引、多目标函数指针
    *   **Unknown (未知)**：明确标注，提示用户补充
        *   外部库无知识库、复杂间接调用

*   [ ] **UI 展示方式**
    *   确定：实线箭头 `────────→`
    *   可能：虚线箭头 `- - - - →` + 列出所有可能目标
    *   未知：`❓` 标记 + 提示 "需要补充信息"

*   [ ] **绝不猜测**
    *   不给出"可能是 A"这种单一猜测
    *   要么确定，要么列出所有可能，要么说不知道
    *   用户看到的任何信息都是 100% 可信的

##### 5.3.5.5 用户辅助学习

*   [ ] **不确定时询问用户**
    *   弹出提示："这个函数指针可能指向哪个函数？"
    *   提供候选列表（基于类型匹配）
*   [ ] **记住用户选择**
    *   存储到项目配置文件
    *   下次分析时自动应用
*   [ ] **导出为知识库**
    *   用户标注可以导出为 YAML 知识库
    *   可以分享给其他用户

##### 5.3.5.6 外部库处理策略

*   [x] **知识库（已有）**：预置 Linux 内核、Android 等调用链
*   [ ] **头文件分析**
    *   解析头文件中的函数声明
    *   推断：参数是 callback 类型 → 可能是注册函数
    *   推断：函数名含 register/add → 可能是注册函数
*   [ ] **未知函数标记**
    *   无法分析的外部调用：标记为 "📦 外部调用"
    *   提示用户：可以添加到知识库

### 5.4 Phase 2: IDE 交互体验 (12 周)

**目标**: 打造流畅的交互式 IDE

#### 5.4.0 技术选型决策

**代码编辑器**（完整 IDE 体验）:

| 组件 | 选择 | 理由 |
|------|------|------|
| 编辑器核心 | **Monaco Editor** | VS Code 同款，功能完整，生态成熟 |
| LSP 集成 | **monaco-languageclient** | 连接 clangd/rust-analyzer 等 LSP |
| 文件管理 | Tauri fs API | 读写本地文件系统 |

**执行流可视化**:

| 阶段 | 选择 | 理由 |
|------|------|------|
| v0.x ~ v1.0 | **React Flow** | 开发效率高，内置拖拽/缩放，支持 1000+ 节点 |
| v1.x (如性能不够) | Canvas + dagre | 虚拟化渲染，支持 10000+ 节点 |

> 💡 **设计原则**: FlowSight = 完整代码编辑器 + 实时执行流可视化 + AI 理解
> 
> 目标：成为开发者最喜欢的代码阅读和编辑工具，取代现有 IDE。
> 
> 核心优势：改代码 → 实时看到执行流变化 → 真正理解代码

#### 5.4.0.1 ⭐ 短期 UI/UX 改进 — ✅ 已完成

> **状态**: 已完成 (2026-01-06)  
> **来源**: 实际使用反馈  
> **实际用时**: ~3h

| # | 功能 | 优先级 | 状态 | 实际工时 |
|---|------|--------|------|----------|
| 1 | 历史导航 (后退/前进) | 🔴 最高 | ✅ 完成 | 1h |
| 2 | 隐藏内核API开关 | 🔴 最高 | ✅ 完成 | 0.5h |
| 3 | 代码→图联动 | 🟡 中等 | ✅ 完成 | 0.5h |
| 4 | 命令面板 (Ctrl+P) | 🟢 一般 | ✅ 完成 | 1h |

**1. 导航体验 ✅**:
*   [x] **历史导航 (后退/前进)** - 点击函数跳转后能一键返回
    *   维护导航历史栈
    *   工具栏添加 ◀ ▶ 按钮
    *   支持 Alt+← / Alt+→ 快捷键
    *   支持鼠标侧键后退
*   [ ] 面包屑导航 - 显示当前位置在调用链中的路径 *(延后)*

**2. 执行流图降噪 ✅**:
*   [x] **"隐藏内核API"开关** - 一键隐藏 `kmalloc`, `printk`, `spin_lock` 等
    *   在工具栏添加 "⚙️ 内核API" 过滤按钮
    *   内置 100+ 常见内核函数列表
*   [x] **子树聚焦** - 右键节点 -> "只看此分支" + 聚焦模式
*   [x] **按深度折叠** - 工具栏层级选择器 (1-5) + 快捷键

**3. 代码编辑器增强 ✅**:
*   [x] 代码 -> 图联动 - 光标在函数名上时，高亮对应流图节点
*   [ ] Ctrl+Click 跳转定义 - 点击函数名跳转到定义 *(需要 LSP)*

**4. 命令面板 ✅**:
*   [x] Ctrl+P / Cmd+P 居中弹出搜索框
*   [x] 支持搜索文件和符号 (@ 前缀搜符号)
*   [x] 支持模糊匹配

#### 5.4.1 完整代码编辑器 (Monaco Editor)

**基础编辑功能**:
*   [x] Monaco Editor 集成
*   [x] 多标签页编辑 ✅ 拖拽排序+关闭
*   [x] 语法高亮 (C/C++/Rust/Go/Java/...)
*   [x] 代码折叠
*   [x] 查找替换 (支持正则) ✅ Ctrl+F/H
*   [x] 多光标编辑 ✅ Monaco 自带
*   [x] 自动保存 ✅ 可配置延迟

**LSP 集成 (智能编辑)**:
*   [ ] clangd 集成 (C/C++)
*   [ ] 自动补全
*   [ ] 跳转到定义 / 查找引用
*   [ ] 悬停显示文档
*   [ ] 重命名符号
*   [ ] 代码诊断 (错误/警告)

**项目管理**:
*   [x] 目录树浏览器
*   [x] 文件创建/删除/重命名 ✅ 右键菜单支持
*   [x] 文件搜索 (Ctrl+P) ✅ 命令面板
*   [x] 全局搜索 (符号搜索)
*   [x] 最近打开的项目 ✅ 欢迎页分类显示

**实时同步**:
*   [x] ⭐ 代码修改 → 增量重新分析 → 执行流图实时更新 ✅
*   [x] 编辑器光标位置 ↔ 图中高亮对应节点 ✅ (代码→图联动)
*   [x] 图中点击节点 → 编辑器跳转到对应代码

#### 5.4.2 交互式执行流图谱 (使用 React Flow)

*   **基础交互**:
    *   [x] 节点点击跳转代码 ✅
    *   [x] 拖拽平移、滚轮缩放 ✅ (React Flow 自带)
    *   [x] 节点悬停显示详情 (函数签名、调用次数、执行上下文) ✅
    *   [x] 边点击显示调用类型 (直接/异步/函数指针) ✅ 颜色区分
*   **智能折叠** (关键！避免图谱过于复杂):
    *   [x] 一键折叠不关心的子系统分支 ✅ 按深度折叠
    *   [ ] 自动识别可折叠的重复模式
    *   [x] 折叠状态持久化 ✅ localStorage 保存
    *   [x] 默认只展开 2 层 ✅
*   **智能聚类**:
    *   [ ] 自动聚合过于复杂的调用关系
    *   [ ] 按模块/目录聚类
    *   [ ] 用户可自定义聚类规则

#### 5.4.3 场景化数据流分析 ⭐⭐⭐ 核心功能 — ✅ 基础版完成

> 用户指定入口参数值 → 看到每个变量在该场景下的值 → 高亮实际执行路径

**场景输入方式（5种）**:

*   **方式1: GUI表单输入**（简单场景）✅ 已实现
    *   [x] 选择入口函数 ✅
    *   [x] 自动解析参数类型，生成表单 ✅ ScenarioPanel
    *   [x] 支持结构体字段展开 ✅ 变量路径支持 (id->idVendor)
    *   [x] 支持指针状态（非空/NULL）✅
    *   [x] 实时预览 ✅ ScenarioResults

*   **方式2: 代码方式输入**（复杂场景）
    *   [ ] 设计场景描述语言 (`.scenario.c`)
    *   [ ] 支持 SCENARIO("name") { ... } 语法
    *   [ ] 支持 MOCK_FUNCTION() 模拟外部函数返回值
    *   [ ] 支持 EXPECT_PATH_TAKEN() 等断言
    *   [ ] 代码高亮和补全
    *   [ ] 可作为自动化测试执行

*   **方式3: 场景模板库**（常见模式）
    *   [ ] 内置常见驱动框架场景模板
    *   [ ] 分类浏览：USB/I2C/SPI/Platform...
    *   [ ] 模板包含：正常路径、错误路径、边界条件
    *   [ ] 支持用户自定义模板
    *   [ ] 模板分享/导入

*   **方式4: 从调用点提取**
    *   [ ] 分析代码中所有调用入口函数的位置
    *   [ ] 自动提取调用时的参数上下文
    *   [ ] 一键生成场景
    *   [ ] 显示调用链上下文

*   **方式5: 从Trace导入**
    *   [ ] 导入 ftrace/perf 运行时记录
    *   [ ] 从寄存器/内存提取参数值
    *   [ ] 自动生成对应场景
    *   [ ] 对比静态分析 vs 实际运行

**场景管理**:
*   [ ] 保存/加载场景配置
*   [ ] 场景分组和标签
*   [ ] 多场景对比视图
*   [ ] 场景导出（可分享给团队）

**数据流追踪**:
*   [ ] 常量传播分析
*   [ ] 表达式求值 (如 `x >> 8`, `a + b`)
*   [ ] 条件分支判定 (根据变量值判断走哪个分支)
*   [ ] 循环迭代追踪 (可配置迭代次数)
*   [ ] 指针/引用追踪

**可视化展示**:
*   [ ] 执行流图：每个节点显示当前变量值
*   [ ] 执行流图：高亮实际会执行的路径
*   [ ] 执行流图：灰显不会执行的分支
*   [ ] 代码编辑器：行内显示变量值 (类似调试器)
*   [ ] 变量面板：显示当前选中节点的所有变量值

**AI 辅助推断**:
*   [ ] 对于无法静态确定的值，用 AI 推断可能的范围
*   [ ] 对于复杂表达式，用 AI 解释计算过程

**技术实现**:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    场景化数据流分析引擎架构                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   用户输入                                                                   │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  场景: usb_probe(interface, id)                                     │   │
│   │        id->idVendor = 0x1234                                        │   │
│   │        id->idProduct = 0x5678                                       │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    符号执行引擎 (flowsight-symbolic)                 │   │
│   │                                                                      │   │
│   │  1. 初始化符号表: { id->idVendor: 0x1234, id->idProduct: 0x5678 }  │   │
│   │  2. 遍历 AST，对每个语句：                                          │   │
│   │     • 赋值语句 → 更新符号表                                         │   │
│   │     • 条件语句 → 求值条件，记录分支选择                             │   │
│   │     • 函数调用 → 递归分析或标记为"需要更多信息"                     │   │
│   │  3. 输出: 每个程序点的变量值 + 执行路径                             │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                         可视化渲染                                   │   │
│   │                                                                      │   │
│   │  • 节点标注变量值                                                   │   │
│   │  • 高亮执行路径 (绿色)                                              │   │
│   │  • 灰显未执行分支                                                   │   │
│   │  • 代码行内显示值                                                   │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 5.4.4 高级数据流可视化 ⭐⭐ 核心 UI

> 针对不同数据类型和场景的专业可视化

**内存生命周期视图**:
*   [ ] 时间线显示内存分配/释放
*   [ ] 高亮未释放的内存（泄漏风险）
*   [ ] 显示 error 路径是否正确清理
*   [ ] 悬停显示分配详情（大小、位置、释放点）

**变量追踪视图**:
*   [ ] 选中变量后显示值变化时间线
*   [ ] 在执行流图中标注值变化点
*   [ ] 变量监视面板（类似调试器 Watch）
*   [ ] 支持表达式监视（如 `dev->status & 0xFF`）

**函数指针关系图**:
*   [ ] ops 表结构可视化
*   [x] 显示"谁调用了这个指针" ✅ CallersView
*   [ ] 显示"这个指针指向哪些函数"
*   [x] 调用场景说明（何时触发）✅ callback_context

**中断/信号时间线**:
*   [ ] 多层时间线（进程上下文/软中断/硬中断）
*   [ ] 上下文切换可视化
*   [x] 显示每个上下文的限制（可睡眠/不可睡眠）✅ 节点标注
*   [x] 异步触发关系连线 ✅ 异步边颜色+动画

**并发执行视图**:
*   [ ] 多线程/多 CPU 时间线
*   [ ] 锁的获取/等待/释放可视化
*   [ ] 临界区高亮
*   [ ] 潜在竞态条件检测和警告
*   [ ] 死锁风险分析

**UI 交互设计**:
*   [x] 视图切换：执行流 / 内存 / 变量 / 并发 ✅ 图形/文本/树形
*   [x] 视图联动：选中一个视图的元素，其他视图同步高亮 ✅ 代码↔图
*   [x] 时间线缩放和拖拽 ✅ React Flow 支持
*   [x] 筛选和搜索 ✅ 执行流内搜索

#### 5.4.5 图谱渲染性能优化

*   **React Flow 优化**:
    *   [x] 使用 `nodeTypes` 自定义节点减少重渲染 ✅
    *   [x] 使用 `useMemo` 缓存节点和边数据 ✅
    *   [x] 开启 `fitView` 和 `minZoom/maxZoom` 限制 ✅
*   **大图谱优化 (1000+ 节点)**:
    *   [ ] 使用 Web Worker 计算 dagre 布局
    *   [ ] 节点虚拟化：只渲染视口内的节点
    *   [ ] 边简化：缩放时隐藏小边
*   **渐进式渲染**:
    *   [ ] 先渲染主路径，再补充细节
    *   [ ] 缩放时动态调整细节层次 (LOD)

#### 5.4.6 代码透视模式 (Code Lens)

> 在代码行上方显示额外信息，帮助快速理解代码

*   [ ] 显示 "⚡ Entry point | Called by: xxx()"
*   [ ] 显示 "🔗 Binds → my_handler() (async)"
*   [ ] 显示执行上下文标记 (可休眠 ✅ / 不可休眠 ⚠️)
*   [ ] 可开关，避免信息过载

#### 5.4.7 知识库 GUI

*   [ ] 实现简单的规则编辑器，允许用户可视化添加规则
*   [ ] 支持从代码选区自动生成规则模板

#### 5.4.8 IDE 完整功能 (v1.0+)

**终端集成**:
*   [ ] 内置终端 (基于 xterm.js)
*   [ ] 多终端标签页
*   [ ] 自动 cd 到项目目录

**Git 集成**:
*   [ ] Git 状态显示 (修改/新增/删除)
*   [ ] 基础 Git 操作 (commit/push/pull)
*   [ ] 差异对比视图
*   [ ] 分支切换

**设置与主题**:
*   [x] 用户设置持久化 ✅ localStorage
*   [x] 多种主题 (深色/浅色/高对比) ✅ 深色+浅色
*   [ ] 快捷键自定义
*   [x] 字体大小/行高调整 ✅ 设置面板

**布局系统**:
*   [x] 可拖拽调整面板大小 ✅ 可调整侧边栏
*   [x] 面板显示/隐藏 ✅ Ctrl+B 切换
*   [ ] 多种布局预设 (编辑器+图谱 左右/上下)
*   [ ] 布局保存与恢复

### 5.5 Phase 3: 完善与 Trace 集成 (12 周)

**目标**: 动态分析支持与准确性验证

#### 5.5.1 Trace 数据导入 (flowsight-trace 新模块)

*   **支持格式**:
    *   [ ] ftrace (text/binary)
    *   [ ] perf.data
    *   [ ] systrace
    *   [ ] LTTng
*   **核心功能**:
    *   [ ] `FtraceImporter`: 解析 ftrace 日志
    *   [ ] `PerfDataParser`: 解析 perf.data
    *   [ ] `TraceMapper`: 将函数地址/符号映射到源码位置
    *   [ ] 流式解析：支持超大 Trace 文件 (GB级)

#### 5.5.2 动态分析可视化

*   **热力图**:
    *   [ ] 在调用图上用颜色深浅表示调用频率
    *   [ ] 显示函数执行时间统计
*   **路径高亮**:
    *   [ ] 高亮实际执行过的路径
    *   [ ] 显示执行时间线
*   **对比视图**:
    *   [ ] 静态分析 vs 实际执行对比
    *   [ ] 发现未覆盖的代码路径

#### 5.5.3 智能文档

*   [x] 一键导出当前分析视图为 Markdown/HTML 报告 ✅ 支持 Markdown/JSON
*   [x] 包含 SVG 流程图、函数说明、关键数据结构定义 ✅ PNG/SVG 导出
*   [ ] 适用于技术评审、交接文档

### 5.6 Phase 4: AI 集成 (8 周) ⭐

**目标**: v1.5 版本，集成 AI 能力

#### 5.6.1 AI 基础架构

*   **新增 crate: flowsight-ai**:
    *   [ ] `AIBackend` trait: 抽象不同 AI 后端
    *   [ ] `OllamaBackend`: 本地模型支持 (Ollama)
    *   [ ] `OpenAIBackend`: OpenAI API 支持
    *   [ ] `AnthropicBackend`: Claude API 支持
    *   [ ] 流式响应处理
*   **Prompt 工程**:
    *   [ ] 设计上下文感知的提示词模板
    *   [ ] 代码片段 + 调用图 + 用户问题 → 结构化 Prompt
    *   [ ] 多轮对话上下文管理

#### 5.6.2 核心 AI 功能

*   **自然语言查询**:
    *   [ ] 用户输入 "找到 USB 热插拔流程"
    *   [ ] AI 理解意图，生成图查询
    *   [ ] 返回相关执行流图 + 解释
*   **代码解释**:
    *   [ ] 选中代码 → "解释这段代码"
    *   [ ] 结合调用图上下文生成解释
    *   [ ] 标注关键点和潜在问题
*   **文档生成**:
    *   [ ] 选择函数 → "生成文档"
    *   [ ] 自动生成包含 SVG 流程图的 Markdown
    *   [ ] 支持自定义模板

#### 5.6.3 AI 设置界面

*   [ ] 后端选择 (本地/云端)
*   [ ] API Key 管理 (安全存储)
*   [ ] 模型选择 (如有多个)
*   [ ] 上下文长度限制设置

---

### 5.7 Phase 5: 质量保证与发布 (12 周)

**目标**: v1.0/v1.5 正式版发布

#### 5.7.1 测试体系

*   **单元测试**:
    *   [ ] 每个模块 80%+ 覆盖率
    *   [ ] 异步模式识别准确性测试
*   **集成测试**:
    *   [ ] 使用真实 Linux 内核代码片段测试
    *   [ ] 收集 50+ 个典型驱动作为测试用例
    *   [ ] 验证异步追踪准确性 (人工标注 ground truth)
*   **性能测试**:
    *   [ ] Linux 内核全量索引时间 < 10 分钟
    *   [ ] 增量更新时间 < 1 秒
    *   [ ] 图谱渲染 1000 节点 60fps
*   **自动化 CI/CD**:
    *   [ ] GitHub Actions 自动运行测试
    *   [ ] 自动构建多平台安装包
    *   [ ] 代码质量检查 (clippy, eslint)

#### 5.7.2 发布准备

*   **多平台打包**: Windows, Linux, macOS
*   **国际化**: 完善中英文翻译
*   **插件系统**: 初步支持用户脚本查询图数据库
*   **文档完善**: 用户手册、API 文档、贡献指南

---

## 9. UI/UX 设计

### 9.1 交互式执行流视图

必须支持高度交互的操作，而不仅仅是静态图片：

*   **双击节点**: 跳转到对应源码行。
*   **右键菜单**: "折叠此分支"、"只看此路径"、"高亮相关数据流"。
*   **面包屑导航**: 在深入复杂调用链时，顶部显示当前路径。
*   **Mini Map**: 鸟瞰图，用于在巨大图谱中导航。

### 9.2 代码透视模式 (X-Ray Mode)

在编辑器行内显示增强信息：

```c
static int hub_probe(struct usb_interface *intf, ...)
{
    // [Code Lens] 2 callers | 1 async trigger
    
    struct usb_hub *hub;
    hub = kzalloc(sizeof(*hub), GFP_KERNEL);
    
    // [Code Lens] Binds to: hub_event()
    INIT_WORK(&hub->work, hub_event);
    
    // ...
}
```

### 9.3 智能文档生成

提供 "导出分析报告" 功能：

1.  用户选择一个入口函数（如 `probe`）。
2.  IDE 自动遍历其调用树。
3.  生成包含 SVG 流程图、函数说明、关键数据结构定义的 Markdown 文档。
4.  适用于技术评审、交接文档。

### 9.4 多视图布局设计 ⭐

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        FlowSight 主界面布局                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  📁 文件  📝 编辑  🔍 视图  📊 分析  🎨 场景  🤖 AI  ❓ 帮助              │
├─────────┬───────────────────────────────────────────────────┬───────────────┤
│         │                                                   │               │
│ 📁      │  ┌─ usb_driver.c ─┬─ Makefile ─┬─ + ─┐           │ 📋 大纲      │
│ 文件    │  │                                    │           │ ├─ probe     │
│ 浏览器  │  │  58 │ static int my_probe(...)     │           │ ├─ disconnect│
│         │  │  59 │ {                            │           │ └─ handler   │
│         │  │     │ // dev->type = 0x56 ←场景值 │           │               │
│         │  │  60 │     dev->type = id->...      │           ├───────────────┤
│         │  │  61 │     if (dev->type == 0x56)   │           │ 📊 变量监视  │
│         │  │     │     // ✅ 进入此分支         │           │ ─────────────│
│         │  │  62 │         init_type_a(dev);    │           │ dev->type: 0x56│
│         │  │  63 │     else                     │           │ dev->status: 1│
│         │  │     │     // ❌ 不执行             │           │ ret: 0        │
│         │  │  64 │         init_type_b(dev);    │           │               │
│         │  │                                    │           │               │
│         │  └────────────────────────────────────┘           │               │
│         │                                                   │               │
│         ├───────────────────────────────────────────────────┤               │
│         │  ┌─ 视图切换: [执行流] [内存] [并发] [时间线] ─┐  │               │
│         │  │                                              │  │               │
│         │  │    ┌─────────┐    ┌─────────┐               │  │               │
│         │  │    │my_probe │───→│init_a   │               │  │               │
│         │  │    │type=0x56│    │         │               │  │               │
│         │  │    └────┬────┘    └─────────┘               │  │               │
│         │  │         │                                   │  │               │
│         │  │    ┌────▼────┐                              │  │               │
│         │  │    │INIT_WORK│──异步──→ [handler]          │  │               │
│         │  │    └─────────┘                              │  │               │
│         │  │                                              │  │               │
│         │  └──────────────────────────────────────────────┘  │               │
│         │                                                   │               │
├─────────┴───────────────────────────────────────────────────┴───────────────┤
│  场景: USB设备0x1234:0x5678 │ 索引: 15,234符号 │ 分析: 就绪 │ AI: 已连接   │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.5 视图切换设计

**视图标签栏**:
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  [📊 执行流] [🧠 内存] [🔄 并发] [⏱️ 时间线] [🔗 函数指针]                 │
└─────────────────────────────────────────────────────────────────────────────┘
     ↓            ↓           ↓            ↓              ↓
  调用关系    内存生命周期  锁/线程     中断/信号      ops表关系
```

**视图联动**:
- 在代码编辑器中选中函数 → 所有视图高亮该函数相关内容
- 在执行流图中点击节点 → 编辑器跳转到对应代码
- 在内存视图中点击变量 → 变量监视面板添加该变量
- 在时间线上点击事件 → 跳转到触发该事件的代码

### 9.6 场景管理界面

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          场景管理器                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  当前场景: USB设备0x1234:0x5678                           [保存] [另存为]   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  入口函数: usb_probe                                                │    │
│  │                                                                      │    │
│  │  参数绑定:                                                           │    │
│  │  ┌─────────────────┬─────────────────────────────────┬───────────┐  │    │
│  │  │ 变量路径        │ 值                               │ 操作     │  │    │
│  │  ├─────────────────┼─────────────────────────────────┼───────────┤  │    │
│  │  │ id->idVendor    │ 0x1234                          │ [删除]   │  │    │
│  │  │ id->idProduct   │ 0x5678                          │ [删除]   │  │    │
│  │  │ interface       │ <非空指针>                      │ [删除]   │  │    │
│  │  └─────────────────┴─────────────────────────────────┴───────────┘  │    │
│  │                                                                      │    │
│  │  [+ 添加参数]                                                        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  已保存的场景:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ • USB设备0x1234:0x5678 (当前)                                       │    │
│  │ • USB设备0xABCD:0xEF01                                              │    │
│  │ • 错误处理路径测试                                                   │    │
│  │ • 内存分配失败场景                                                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  [🔄 分析当前场景]  [📊 对比多个场景]  [📤 导出报告]                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.7 问题检测和警告设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          问题检测面板                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  🔍 检测到 3 个潜在问题                                                     │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ ⚠️ 内存泄漏风险                                          [跳转]    │    │
│  │    文件: usb_driver.c:76                                            │    │
│  │    描述: dev->buffer 在 error_buffer 路径未释放                     │    │
│  │    建议: 在 goto error_buffer 前添加 kfree(dev->buffer)             │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ ⚠️ 可能在中断上下文休眠                                  [跳转]    │    │
│  │    文件: usb_driver.c:120                                           │    │
│  │    描述: my_timer_handler 调用了 kmalloc(GFP_KERNEL)                │    │
│  │    建议: 在软中断上下文使用 GFP_ATOMIC                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ ℹ️ 未使用的函数                                          [跳转]    │    │
│  │    文件: usb_driver.c:200                                           │    │
│  │    描述: debug_dump() 未被任何代码调用                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  [🔄 重新扫描]  [⚙️ 配置检测规则]  [📤 导出报告]                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 10. 架构改进详细设计

### 10.1 增量解析架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           增量解析系统                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   文件修改                                                                   │
│      │                                                                       │
│      ▼                                                                       │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐                   │
│   │ FileWatcher │ ──→ │ TreeCache   │ ──→ │ Incremental │                   │
│   │ (检测变更)  │     │ (获取旧Tree)│     │ Parser      │                   │
│   └─────────────┘     └─────────────┘     └─────────────┘                   │
│                                                  │                           │
│                                                  ▼                           │
│                       ┌─────────────┐     ┌─────────────┐                   │
│                       │ BatchIndexer│ ←── │ DiffAnalyzer│                   │
│                       │ (增量更新DB)│     │ (找出变化)  │                   │
│                       └─────────────┘     └─────────────┘                   │
│                                                                              │
│   关键数据结构：                                                             │
│   • TreeCache: HashMap<PathBuf, (Tree, u64 /* file_hash */)>                │
│   • FileVersion: { path, hash, mtime, indexed_at }                          │
│   • ChangedSymbols: { added: [], removed: [], modified: [] }                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.2 大型项目内存管理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           内存管理策略                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  三级缓存                                                            │   │
│   │                                                                      │   │
│   │  Level 1: 热数据 (当前打开的文件)                                    │   │
│   │  ├── 完整 Tree + ParseResult                                         │   │
│   │  └── 无限制，随打开文件数增长                                        │   │
│   │                                                                      │   │
│   │  Level 2: 温数据 (最近访问的相关文件)                                │   │
│   │  ├── 完整 Tree + ParseResult                                         │   │
│   │  └── LRU 淘汰，最大 100 个文件                                       │   │
│   │                                                                      │   │
│   │  Level 3: 冷数据 (SQLite 持久化)                                     │   │
│   │  ├── 只保存符号信息，不保存 Tree                                     │   │
│   │  └── 需要时从源文件重新解析                                          │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   淘汰策略：                                                                 │
│   • 内存超过阈值时，Level 2 按 LRU 淘汰到 Level 3                          │
│   • 用户关闭文件时，从 Level 1 移到 Level 2                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.3 进度报告系统

```rust
// 进度事件定义
#[derive(Serialize, Clone)]
pub struct ProgressEvent {
    pub phase: ProgressPhase,
    pub current: u64,
    pub total: u64,
    pub message: String,
    pub cancelable: bool,
}

#[derive(Serialize, Clone)]
pub enum ProgressPhase {
    Scanning,      // 扫描文件
    Parsing,       // 解析代码
    Analyzing,     // 分析异步/函数指针
    Indexing,      // 写入索引
    BuildingGraph, // 构建调用图
}

// 前端订阅
tauri::listen("indexing-progress", |event| {
    const progress = event.payload;
    updateProgressBar(progress.current / progress.total);
    updateStatusText(progress.message);
});
```

### 10.4 智能折叠算法

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           智能折叠策略                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   规则 1: 深度折叠                                                           │
│   • 默认只展开 2 层                                                          │
│   • 超过深度的节点自动折叠为 "... (5 more calls)"                           │
│                                                                              │
│   规则 2: 子系统折叠                                                         │
│   • 识别子系统边界 (如 drivers/usb/, fs/, net/)                             │
│   • 进入其他子系统的调用可折叠为 "[USB subsystem]"                          │
│                                                                              │
│   规则 3: 重复模式折叠                                                       │
│   • 检测重复的调用模式 (如 多个 kfree() 调用)                               │
│   • 聚合为 "kfree() x 3"                                                    │
│                                                                              │
│   规则 4: 内核 API 折叠                                                      │
│   • 常见内核 API (kmalloc, printk, spin_lock 等) 可一键隐藏                 │
│   • 用户可配置 "不关心的函数列表"                                           │
│                                                                              │
│   交互：                                                                     │
│   • 点击折叠节点展开详情                                                     │
│   • 右键菜单: "只看这条路径" / "隐藏这个分支"                               │
│   • 快捷键: Ctrl+F 聚焦当前函数的调用链                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.5 新增 Crate: flowsight-trace

```
crates/flowsight-trace/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── ftrace.rs       # ftrace 日志解析
│   ├── perf.rs         # perf.data 解析
│   ├── systrace.rs     # systrace 解析
│   ├── mapper.rs       # 地址/符号 → 源码映射
│   └── timeline.rs     # 时间线数据结构
```

### 10.6 场景描述语言设计 (FlowSight Scenario Language)

> 用代码方式定义复杂分析场景，支持模拟、断言和自动化测试

#### 语法设计

```c
// 文件: my_driver.scenario.c
#include <flowsight/scenario.h>

// ============================================
// 场景1: USB 设备正常探测
// ============================================
SCENARIO("USB Type A 设备正常探测") {
    DESCRIPTION("测试 USB 设备 0x1234:0x5678 的探测流程");
    TAGS("usb", "probe", "happy-path");
    
    // 入口函数
    ENTRY(usb_probe);
    
    // 定义输入参数
    PARAM(struct usb_interface*, interface) {
        .dev.driver = &my_driver,
        .cur_altsetting = VALID_POINTER,
    };
    
    PARAM(const struct usb_device_id*, id) {
        .idVendor = 0x1234,
        .idProduct = 0x5678,
        .bDeviceClass = USB_CLASS_VENDOR_SPEC,
    };
    
    // 模拟外部函数行为
    MOCK(kzalloc) {
        ON_CALL(ANY, GFP_KERNEL).RETURN(VALID_POINTER);
    }
    
    MOCK(kmalloc) {
        ON_CALL(4096, GFP_KERNEL).RETURN(VALID_POINTER);
    }
    
    MOCK(usb_get_dev) {
        RETURN(VALID_POINTER);
    }
    
    // 运行分析
    RUN();
    
    // 验证执行路径
    EXPECT_PATH("init_type_a");
    EXPECT_NOT_PATH("init_type_b");
    EXPECT_NOT_PATH("error_buffer");
    
    // 验证变量值
    EXPECT_VAR("dev->type", EQUALS, 0x56);
    EXPECT_VAR("ret", EQUALS, 0);
    
    // 验证返回值
    EXPECT_RETURN(0);
}

// ============================================
// 场景2: 内存分配失败
// ============================================
SCENARIO("USB 探测 - 内存分配失败") {
    DESCRIPTION("测试 kzalloc 返回 NULL 时的错误处理");
    TAGS("usb", "probe", "error-path", "memory");
    
    ENTRY(usb_probe);
    
    PARAM(struct usb_interface*, interface) { ... };
    PARAM(const struct usb_device_id*, id) { ... };
    
    // 模拟内存分配失败
    MOCK(kzalloc) {
        RETURN(NULL);
    }
    
    RUN();
    
    // 验证错误路径
    EXPECT_PATH("error");
    EXPECT_RETURN(-ENOMEM);
    
    // 验证没有内存泄漏（因为分配失败了）
    EXPECT_NO_MEMORY_LEAK();
}

// ============================================
// 场景3: 参数化场景
// ============================================
SCENARIO_TEMPLATE("USB 设备探测", vendor, product) {
    ENTRY(usb_probe);
    
    PARAM(const struct usb_device_id*, id) {
        .idVendor = vendor,
        .idProduct = product,
    };
    
    // ...
}

// 用不同参数实例化
INSTANTIATE(USB_DEVICE_A, 0x1234, 0x5678);
INSTANTIATE(USB_DEVICE_B, 0xABCD, 0xEF01);
INSTANTIATE(USB_DEVICE_C, 0x0000, 0x0000);  // 边界测试
```

#### 内置宏和函数

```c
// 场景定义
SCENARIO(name)              // 定义场景
SCENARIO_TEMPLATE(name, params...)  // 参数化场景模板
DESCRIPTION(text)           // 场景描述
TAGS(...)                   // 标签，用于筛选

// 入口和参数
ENTRY(function)             // 入口函数
PARAM(type, name) { ... }   // 参数定义

// 模拟
MOCK(function) { ... }      // 模拟函数
ON_CALL(args...).RETURN(value)  // 条件返回
RETURN(value)               // 无条件返回
VALID_POINTER               // 有效指针（非NULL）
NULL_POINTER                // 空指针
ANY                         // 任意值

// 执行
RUN()                       // 运行分析

// 断言 - 路径
EXPECT_PATH(name)           // 期望经过此路径
EXPECT_NOT_PATH(name)       // 期望不经过此路径

// 断言 - 变量
EXPECT_VAR(expr, op, value) // 验证变量值
// op: EQUALS, NOT_EQUALS, GREATER, LESS, IN_RANGE

// 断言 - 返回值
EXPECT_RETURN(value)        // 验证返回值

// 断言 - 内存
EXPECT_NO_MEMORY_LEAK()     // 无内存泄漏
EXPECT_MEMORY_FREED(var)    // 变量已释放

// 断言 - 并发
EXPECT_LOCK_HELD(lock)      // 持有锁
EXPECT_LOCK_NOT_HELD(lock)  // 未持有锁
```

### 10.7 新增 Crate: flowsight-symbolic ⭐ 核心

> 场景化数据流分析引擎 —— 让用户指定输入参数，看到变量在每个节点的值

```
crates/flowsight-symbolic/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── scenario.rs     # 场景定义 (用户输入的参数值)
│   ├── symbol_table.rs # 符号表 (变量名 → 值)
│   ├── evaluator.rs    # 表达式求值器
│   ├── executor.rs     # 符号执行引擎
│   ├── branch.rs       # 分支条件判定
│   └── path.rs         # 执行路径记录
```

#### 核心数据结构

```rust
/// 场景定义 - 用户指定的输入参数
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Scenario {
    /// 入口函数
    pub entry_function: String,
    /// 参数值绑定
    pub bindings: Vec<ValueBinding>,
    /// 场景名称 (用于保存/加载)
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValueBinding {
    /// 变量路径 (如 "id->idVendor")
    pub path: String,
    /// 值 (支持整数、字符串、结构体)
    pub value: SymbolicValue,
}

/// 符号值
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SymbolicValue {
    /// 具体整数值
    Integer(i64),
    /// 具体字符串
    String(String),
    /// 指针 (已分配/NULL)
    Pointer { is_null: bool, size: Option<usize> },
    /// 未知值 (需要AI推断或用户指定)
    Unknown { hint: Option<String> },
    /// 范围 (如 0..100)
    Range { min: i64, max: i64 },
}

/// 程序点的状态
#[derive(Debug, Clone)]
pub struct ProgramState {
    /// 当前位置
    pub location: Location,
    /// 符号表 (变量 → 值)
    pub symbols: HashMap<String, SymbolicValue>,
    /// 此路径是否可达
    pub reachable: bool,
    /// 条件分支选择
    pub branch_taken: Option<bool>,
}

/// 执行路径
#[derive(Debug, Clone)]
pub struct ExecutionPath {
    /// 路径上的所有程序状态
    pub states: Vec<ProgramState>,
    /// 路径是否完整执行
    pub completed: bool,
    /// 终止原因 (如果未完成)
    pub termination_reason: Option<String>,
}
```

#### 使用示例

```rust
// 创建场景
let scenario = Scenario {
    entry_function: "usb_probe".to_string(),
    name: "USB设备0x1234:0x5678".to_string(),
    bindings: vec![
        ValueBinding {
            path: "id->idVendor".to_string(),
            value: SymbolicValue::Integer(0x1234),
        },
        ValueBinding {
            path: "id->idProduct".to_string(),
            value: SymbolicValue::Integer(0x5678),
        },
    ],
};

// 执行符号分析
let executor = SymbolicExecutor::new();
let path = executor.execute(&scenario, &parse_result)?;

// 获取每个节点的变量值
for state in &path.states {
    println!("At {}: {:?}", state.location, state.symbols);
}
```

---

## 11. 风险评估与应对 (更新)

| 风险 | 可能性 | 影响 | 应对策略 |
|------|--------|------|----------|
| **LSP 集成复杂** | 中 | 中 | 使用成熟的 `monaco-languageclient` 库，不从零实现 |
| **图谱过于复杂** | 高 | 高 | **必须**实现智能折叠和聚类算法，默认只展开 2 层 |
| **Trace 数据量大** | 中 | 中 | 采用流式解析，只加载当前视图相关的时间段 |
| **Kconfig 解析繁琐** | 中 | 低 | 借用 Linux 内核自带的 `conf` 工具或现有 Python 库 |
| **增量解析实现复杂** | 中 | 高 | 先实现文件级增量，再优化到函数级 |
| **大型项目内存溢出** | 中 | 高 | 实现三级缓存 + LRU 淘汰策略 |
| **索引首次构建慢** | 高 | 中 | 后台线程 + 进度指示 + 优先索引用户打开的文件 |

---

## 12. 资源估算

*   **核心开发**: 2-3 人 (Rust/Tauri)
*   **前端交互**: 1-2 人 (React/D3/Canvas) - **交互式图谱需要重点投入**
*   **测试设备**: Windows 开发机 + Linux 编译服务器

---

## 13. 成功指标

### 13.1 技术指标

| 指标 | 目标值 | 测量方法 |
|------|--------|----------|
| Linux 内核全量索引时间 | < 10 分钟 | 测试 Linux 6.x 完整源码 |
| 增量更新时间 | < 1 秒 | 修改单个文件后的响应时间 |
| 内存占用 (内核项目) | < 4 GB | 索引完成后的稳定内存 |
| 图谱渲染 1000 节点 | 60 fps | 拖拽平移时的帧率 |
| 异步追踪准确率 | > 95% | 与人工标注对比 |

### 13.2 用户体验指标

| 指标 | 目标值 | 测量方法 |
|------|--------|----------|
| 首次使用到看到结果 | < 5 分钟 | 用户测试 |
| 核心功能可发现性 | > 80% | 用户能自己找到主要功能 |
| 任务完成率 | > 90% | 用户能完成典型分析任务 |

### 13.3 社区指标 (开源)

| 指标 | 1年目标 | 3年目标 |
|------|---------|---------|
| GitHub Stars | 1,000+ | 10,000+ |
| 活跃贡献者 | 5+ | 20+ |
| 月下载量 | 500+ | 5,000+ |
| 用户反馈 Issue | 持续收到 | 形成社区 |

---

## 14. 扩展性设计

### 14.1 多语言支持架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           多语言支持架构                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  Language Trait (抽象接口)                                           │   │
│   │                                                                      │   │
│   │  pub trait LanguageSupport {                                         │   │
│   │      fn parse(&self, source: &str) -> ParseResult;                   │   │
│   │      fn get_async_patterns(&self) -> Vec<AsyncPattern>;              │   │
│   │      fn get_funcptr_patterns(&self) -> Vec<FuncPtrPattern>;          │   │
│   │  }                                                                   │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│          ┌──────────────────┼──────────────────┐                            │
│          ▼                  ▼                  ▼                            │
│   ┌────────────┐    ┌────────────┐    ┌────────────┐                        │
│   │ C Language │    │ Rust Lang  │    │ Go Lang    │                        │
│   │ Support    │    │ Support    │    │ Support    │                        │
│   └────────────┘    └────────────┘    └────────────┘                        │
│                                                                              │
│   每种语言实现自己的：                                                       │
│   • tree-sitter grammar                                                     │
│   • 异步模式识别 (tokio, goroutine, etc.)                                   │
│   • 函数指针/trait/interface 解析                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 14.2 知识库扩展架构

```
knowledge/
├── schemas/                    # JSON Schema 定义
│   ├── async_pattern.schema.json
│   ├── framework.schema.json
│   └── bridge.schema.json
├── languages/                  # 语言级别模式
│   ├── c/
│   ├── rust/
│   └── go/
├── platforms/                  # 平台级别模式
│   ├── linux-kernel/
│   ├── android/
│   └── embedded/
└── bridges/                    # 跨语言桥接
    └── jni.yaml
```

**扩展新平台只需：**
1. 创建新目录 `platforms/new-platform/`
2. 编写 YAML 规则文件
3. 无需修改代码，自动加载

### 14.3 插件系统设计 (v2.0+)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           插件系统                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   插件类型：                                                                 │
│   ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐              │
│   │ 语言插件   │ │ 分析插件   │ │ 可视化插件 │ │ 导出插件   │              │
│   │ (新语法)   │ │ (新规则)   │ │ (新图表)   │ │ (新格式)   │              │
│   └────────────┘ └────────────┘ └────────────┘ └────────────┘              │
│                                                                              │
│   插件接口 (Lua/WASM)：                                                      │
│   • register_pattern(name, regex, handler)                                  │
│   • query_callgraph(from, to, depth)                                        │
│   • add_visualization(type, data)                                           │
│   • export_data(format, path)                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 14.4 AI 集成设计 (v1.5+) ⭐

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           AI 集成架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                         AI 功能层                                    │   │
│   │  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐        │   │
│   │  │ 自然语言   │ │ 代码解释   │ │ 文档生成   │ │ Bug 分析   │        │   │
│   │  │ 查询       │ │            │ │            │ │            │        │   │
│   │  └────────────┘ └────────────┘ └────────────┘ └────────────┘        │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                     │                                        │
│                                     ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                       AI 抽象层 (flowsight-ai)                       │   │
│   │  • PromptBuilder: 构建上下文感知的提示词                            │   │
│   │  • RAGEngine: 基于索引的检索增强生成                                │   │
│   │  • StreamHandler: 流式响应处理                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                     │                                        │
│                          ┌──────────┴──────────┐                            │
│                          ▼                     ▼                            │
│   ┌─────────────────────────────┐ ┌─────────────────────────────┐           │
│   │      本地模型后端           │ │      云端 API 后端          │           │
│   │  • Ollama (Llama/Qwen)      │ │  • OpenAI API               │           │
│   │  • llama.cpp                │ │  • Anthropic API            │           │
│   │  • MLX (Apple Silicon)      │ │  • Azure OpenAI             │           │
│   │                             │ │  • 其他兼容 API             │           │
│   │  优点: 隐私、离线可用       │ │  优点: 更强大、无需GPU      │           │
│   └─────────────────────────────┘ └─────────────────────────────┘           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### AI 功能详细设计

**v1.5 - 基础 AI 功能：**

| 功能 | 描述 | 实现方式 |
|------|------|----------|
| **自然语言查询** | "找到 USB 热插拔的处理流程" | AI 理解意图 → 生成图查询 → 返回执行流 |
| **代码解释** | 选中代码 → 解释功能 | 代码 + 上下文 → AI 生成解释 |
| **文档生成** | 选择函数 → 生成文档 | 调用图 + 代码 → Markdown |

**v2.0 - 高级 AI 功能：**

| 功能 | 描述 | 实现方式 |
|------|------|----------|
| **代码问答 (RAG)** | 任意问题 → 准确回答 | 检索相关代码 → 增强上下文 → 生成答案 |
| **Bug 分析** | 崩溃点 → 分析原因 | 执行路径 + 上下文 → AI 分析 |
| **代码审查** | 补丁 → 影响分析 | 差异 + 调用图 → 影响范围 |

**技术选型：**
- 用户可选择本地模型或云端 API
- 本地模型推荐：Ollama + Qwen2.5-Coder / DeepSeek-Coder
- 云端 API 支持：OpenAI、Anthropic、Azure 等
