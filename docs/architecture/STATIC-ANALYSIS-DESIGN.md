# 🔬 FlowSight 纯静态分析技术方案

> **核心目标**：不运行代码，纯粹通过阅读源代码，自动分析出函数的真实执行流程。
> 
> **价值**：让水平一般的程序员也能快速看懂十几万行代码的复杂调用关系。

---

## 目录

1. [问题定义](#1-问题定义)
2. [技术原理](#2-技术原理)
3. [核心算法](#3-核心算法)
4. [实现方案](#4-实现方案)
5. [难点与解决](#5-难点与解决)
6. [实现步骤](#6-实现步骤)
7. [准确度评估](#7-准确度评估)

---

## 1. 问题定义

### 1.1 我们要解决的三类问题

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        执行流分析的三类问题                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  问题1：直接调用（简单）                                                │
│  ════════════════════════                                               │
│  void foo() {                                                           │
│      bar();  ← 语法分析就能确定：foo 调用 bar                           │
│  }                                                                      │
│                                                                          │
│  问题2：间接调用（核心难点）                                            │
│  ══════════════════════════                                             │
│  void (*fp)(void);                                                      │
│  fp = func_a;                                                           │
│  if (cond) fp = func_b;                                                 │
│  fp();  ← fp 指向谁？需要指针分析                                       │
│                                                                          │
│  问题3：异步调用（最复杂）                                              │
│  ════════════════════════                                               │
│  register_callback(my_handler);  // 注册                                │
│  ...                                                                    │
│  // my_handler 什么时候被调用？谁调用？                                 │
│  // 需要理解"注册-触发"的关系                                          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 人是怎么看懂这些的？

```
人阅读代码时的思维过程：

1. 看到 `fp = func_a`
   → 记住：fp 可能指向 func_a

2. 看到 `if (cond) fp = func_b`
   → 记住：fp 也可能指向 func_b

3. 看到 `fp()`
   → 回忆：fp 指向 {func_a, func_b}
   → 结论：这里会调用 func_a 或 func_b

4. 看到 `register_callback(my_handler)`
   → 推断：my_handler 被注册了
   → 推断：未来某处会调用它

5. 看到 `trigger_event()`
   → 推断：这可能触发所有注册的 callback

FlowSight 的目标：自动化这个思维过程！
```

---

## 2. 技术原理

### 2.1 编译原理基础

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         编译原理知识体系                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  词法分析 (Lexical Analysis)                                            │
│  ──────────────────────────                                             │
│  源代码 → Token 流                                                      │
│  "int x = 5;" → [INT, IDENT(x), ASSIGN, NUM(5), SEMICOLON]             │
│                                                                          │
│  语法分析 (Syntax Analysis)                                             │
│  ──────────────────────────                                             │
│  Token 流 → AST (抽象语法树)                                            │
│                                                                          │
│       VarDecl                                                           │
│       /  |  \                                                           │
│    int  x   5                                                           │
│                                                                          │
│  语义分析 (Semantic Analysis)                                           │
│  ──────────────────────────                                             │
│  • 类型检查                                                             │
│  • 符号表构建                                                           │
│  • 作用域分析                                                           │
│                                                                          │
│  FlowSight 使用的：                                                     │
│  • Tree-sitter：词法 + 语法分析                                        │
│  • 自己实现：语义分析 + 更高级的分析                                   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 程序分析理论

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         程序分析核心概念                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  控制流分析 (Control Flow Analysis)                                     │
│  ═════════════════════════════════                                      │
│  • 构建 CFG (控制流图)                                                  │
│  • 确定代码的执行顺序                                                   │
│                                                                          │
│      if (x > 0) {          ┌───┐                                       │
│          a();      →       │ if │                                       │
│      } else {             /     \                                       │
│          b();           ┌─┐     ┌─┐                                    │
│      }                  │a│     │b│                                    │
│                          └─┘     └─┘                                    │
│                            \     /                                      │
│                            ┌─────┐                                     │
│                            │ end │                                     │
│                            └─────┘                                     │
│                                                                          │
│  数据流分析 (Data Flow Analysis)                                        │
│  ═════════════════════════════════                                      │
│  • 追踪变量的定义和使用                                                 │
│  • def-use chain：定义-使用链                                          │
│                                                                          │
│      x = 5;       // def(x)                                            │
│      y = x + 1;   // use(x), def(y)                                    │
│      print(y);    // use(y)                                            │
│                                                                          │
│      def-use chain: x(line1) → x(line2)                                │
│                     y(line2) → y(line3)                                │
│                                                                          │
│  指针分析 (Pointer Analysis) ⭐ 核心                                    │
│  ═══════════════════════════════════                                    │
│  • 确定指针变量可能指向的对象                                           │
│  • Points-to 集合：pts(p) = {可能指向的对象}                           │
│                                                                          │
│      int *p = &x;          pts(p) = {x}                                │
│      int *q = &y;          pts(q) = {y}                                │
│      if (cond) p = q;      pts(p) = {x, y}                             │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 核心算法

### 3.1 指针分析算法

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      指针分析算法选择                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  算法               精确度      复杂度      适用场景                    │
│  ─────────────────────────────────────────────────────────────────────   │
│  Steensgaard       ★★☆☆☆      O(n)       超大代码，快速粗略            │
│  Andersen          ★★★★☆      O(n³)      中等代码，较精确              │
│  Flow-Sensitive    ★★★★★      O(n⁴)      小代码，高精确                │
│                                                                          │
│  FlowSight 策略：                                                       │
│  ═══════════════                                                        │
│  1. 默认使用 Andersen 算法（精确度和性能的平衡）                        │
│  2. 对于超大项目，可以降级到 Steensgaard                               │
│  3. 对于关键函数，可以使用 Flow-Sensitive                              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### Andersen 算法详解

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Andersen 算法原理                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  核心思想：将指针赋值转换为约束，然后求解                               │
│                                                                          │
│  约束类型：                                                             │
│  ──────────                                                             │
│  语句              约束                  含义                           │
│  ─────────────────────────────────────────────────────────────────────   │
│  p = &x           x ∈ pts(p)           p 指向 x                         │
│  p = q            pts(q) ⊆ pts(p)      p 指向 q 指向的所有对象         │
│  p = *q           ∀o∈pts(q): pts(o)⊆pts(p)   解引用                    │
│  *p = q           ∀o∈pts(p): pts(q)⊆pts(o)   通过指针赋值              │
│                                                                          │
│  示例：                                                                 │
│  ──────                                                                 │
│  void (*fp)(void);                                                      │
│  fp = func_a;           // 约束：func_a ∈ pts(fp)                      │
│  if (cond)                                                              │
│      fp = func_b;       // 约束：func_b ∈ pts(fp)                      │
│  fp();                  // 调用 pts(fp) = {func_a, func_b}             │
│                                                                          │
│  求解过程：                                                             │
│  ────────                                                               │
│  1. 收集所有约束                                                        │
│  2. 初始化：处理所有 p = &x 约束                                        │
│  3. 迭代传播：直到不动点                                                │
│     - 对于 p = q：将 pts(q) 加入 pts(p)                                │
│     - 对于 p = *q：对于 q 指向的每个 o，将 pts(o) 加入 pts(p)          │
│     - 对于 *p = q：对于 p 指向的每个 o，将 pts(q) 加入 pts(o)          │
│  4. 输出每个指针的 points-to 集合                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 异步模式识别算法

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    通用异步模式识别                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  核心思想：识别"绑定"和"调用"的对应关系                                │
│                                                                          │
│  步骤1：找到所有函数指针类型的变量/字段                                │
│  ═══════════════════════════════════════                                │
│  • 解析类型声明，找到 void (*)(xxx) 类型                               │
│  • 解析结构体，找到函数指针类型的字段                                   │
│  • 解析函数参数，找到 callback 类型的参数                               │
│                                                                          │
│  步骤2：追踪赋值（绑定）                                                │
│  ════════════════════════                                               │
│  fp = my_func;              // 直接赋值                                 │
│  obj->callback = my_func;   // 字段赋值                                 │
│  register_func(my_func);    // 参数传递                                 │
│                                                                          │
│  步骤3：追踪调用（触发）                                                │
│  ════════════════════════                                               │
│  fp();                      // 直接调用                                 │
│  obj->callback();           // 字段调用                                 │
│  call_registered_funcs();   // 批量触发（需要分析函数内部）            │
│                                                                          │
│  步骤4：建立绑定-触发关系                                               │
│  ════════════════════════════                                           │
│                                                                          │
│      绑定点                    触发点                                   │
│    ┌─────────┐              ┌─────────┐                                │
│    │ fp =    │    ────→    │ fp()    │                                │
│    │ my_func │              │         │                                │
│    └─────────┘              └─────────┘                                │
│                                                                          │
│    ┌──────────────┐        ┌──────────────┐                            │
│    │obj->cb =     │ ────→  │obj->cb()     │                            │
│    │handler       │        │              │                            │
│    └──────────────┘        └──────────────┘                            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.3 常见异步模式

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       常见异步模式识别                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  模式1：简单 Callback                                                   │
│  ═══════════════════════                                                │
│  代码特征：                                                             │
│    obj->callback = handler;  // 赋值                                   │
│    ...                                                                  │
│    obj->callback(args);      // 调用                                   │
│                                                                          │
│  识别方法：                                                             │
│    1. 找到结构体字段是函数指针类型                                      │
│    2. 追踪该字段的赋值                                                  │
│    3. 追踪该字段的调用                                                  │
│                                                                          │
│  模式2：注册函数模式                                                    │
│  ═════════════════════                                                  │
│  代码特征：                                                             │
│    register_xxx(handler);    // 注册                                   │
│    ...                                                                  │
│    // handler 会在某个条件下被调用                                      │
│                                                                          │
│  识别方法：                                                             │
│    1. 找到函数参数是函数指针类型                                        │
│    2. 推断该函数是"注册函数"                                           │
│    3. 分析注册函数内部，找到 callback 存储位置                         │
│    4. 找到该存储位置的调用点                                            │
│                                                                          │
│  模式3：事件循环模式                                                    │
│  ═══════════════════                                                    │
│  代码特征：                                                             │
│    while (1) {                                                          │
│        event = get_event();                                             │
│        handlers[event.type](event);  // 或 dispatch(event)             │
│    }                                                                    │
│                                                                          │
│  识别方法：                                                             │
│    1. 找到无限循环                                                      │
│    2. 找到循环内的"获取事件"模式                                       │
│    3. 找到"分发事件"模式（数组索引或 switch）                          │
│    4. 追踪 handlers 数组的赋值                                          │
│                                                                          │
│  模式4：队列/工作队列模式                                               │
│  ═══════════════════════                                                │
│  代码特征：                                                             │
│    enqueue(queue, work);     // 入队                                   │
│    ...                                                                  │
│    work = dequeue(queue);    // 出队                                   │
│    work->func();             // 执行                                   │
│                                                                          │
│  识别方法：                                                             │
│    1. 找到队列操作函数（push/pop, enqueue/dequeue）                    │
│    2. 追踪队列元素的流动                                                │
│    3. 找到出队后的处理                                                  │
│                                                                          │
│  模式5：信号/槽模式                                                     │
│  ═══════════════════                                                    │
│  代码特征：                                                             │
│    connect(signal, slot);    // 连接                                   │
│    ...                                                                  │
│    emit(signal);             // 发射                                   │
│                                                                          │
│  识别方法：                                                             │
│    1. 找到 connect/on/bind 类函数调用                                  │
│    2. 提取 signal 和 slot                                              │
│    3. 找到 emit/trigger/fire 类函数调用                                │
│    4. 建立 signal → slot 映射                                          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 实现方案

### 4.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     FlowSight 分析引擎架构                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  源代码 (.c, .cpp, .java, .rs, .go, .py, ...)                          │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  Stage 1: 解析 (Parser)                                          │    │
│  │  ─────────────────────────                                       │    │
│  │  • 输入：源代码                                                  │    │
│  │  • 输出：AST + 符号表                                            │    │
│  │  • 工具：Tree-sitter (多语言支持)                               │    │
│  │  • 时间：O(n), n = 代码行数                                     │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  Stage 2: 类型分析 (Type Analysis)                               │    │
│  │  ─────────────────────────────────                               │    │
│  │  • 输入：AST + 符号表                                            │    │
│  │  • 输出：类型信息，特别是函数指针类型                            │    │
│  │  • 关键：识别 callback 类型的参数和字段                          │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  Stage 3: 直接调用分析 (Direct Call Analysis)                    │    │
│  │  ─────────────────────────────────────────────                   │    │
│  │  • 输入：AST                                                     │    │
│  │  • 输出：直接调用边 {(caller, callee, location)}                 │    │
│  │  • 方法：遍历 AST，找到函数调用节点                              │    │
│  │  • 准确度：100%                                                  │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  Stage 4: 指针分析 (Pointer Analysis) ⭐ 核心                     │    │
│  │  ─────────────────────────────────────────                       │    │
│  │  • 输入：AST + 类型信息                                          │    │
│  │  • 输出：Points-to 集合 {ptr → {target1, target2, ...}}         │    │
│  │  • 算法：Andersen (默认) / Steensgaard (大项目)                 │    │
│  │  • 时间：O(n³) / O(n)                                           │    │
│  │  • 准确度：85-95%                                                │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  Stage 5: 异步模式识别 (Async Pattern Recognition)               │    │
│  │  ─────────────────────────────────────────────────               │    │
│  │  • 输入：AST + 类型信息 + Points-to 集合                         │    │
│  │  • 输出：异步绑定关系 {(bind_location, trigger_location, handler)}│    │
│  │  • 方法：                                                        │    │
│  │    - 已知框架：模式匹配（知识库）                                │    │
│  │    - 通用分析：追踪函数指针的绑定和调用                          │    │
│  │  • 准确度：70-95%（取决于代码复杂度）                           │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  Stage 6: 执行流构建 (Flow Construction)                         │    │
│  │  ─────────────────────────────────────────                       │    │
│  │  • 输入：直接调用 + 间接调用 + 异步绑定                          │    │
│  │  • 输出：完整的执行流图                                          │    │
│  │  • 包含：                                                        │    │
│  │    - 调用关系（直接/间接）                                       │    │
│  │    - 异步触发关系                                                │    │
│  │    - 置信度标注                                                  │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                  │
│       ▼                                                                  │
│  输出：执行流图 (Flow Graph)                                            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 数据结构设计

```rust
// ============================================
// 指针分析数据结构
// ============================================

/// 变量标识
enum Variable {
    /// 局部变量: function::name
    Local { function: String, name: String },
    
    /// 全局变量
    Global { name: String },
    
    /// 结构体字段: base.field
    Field { base: Box<Variable>, field: String },
    
    /// 函数（作为指针目标）
    Function { name: String },
}

/// Points-to 集合
struct PointsToSet {
    /// 变量 → 可能指向的目标集合
    sets: HashMap<Variable, HashSet<Variable>>,
}

/// 约束
enum Constraint {
    /// p = &x: x 加入 pts(p)
    AddressOf { pointer: Variable, target: Variable },
    
    /// p = q: pts(q) ⊆ pts(p)
    Copy { to: Variable, from: Variable },
    
    /// p = *q: ∀o∈pts(q): pts(o) ⊆ pts(p)
    Load { to: Variable, from: Variable },
    
    /// *p = q: ∀o∈pts(p): pts(q) ⊆ pts(o)
    Store { to: Variable, from: Variable },
}

// ============================================
// 异步分析数据结构
// ============================================

/// 异步绑定
struct AsyncBinding {
    /// 绑定位置（代码中赋值的地方）
    bind_location: Location,
    
    /// 被绑定的处理函数
    handler: String,
    
    /// 绑定变量/字段
    variable: Variable,
    
    /// 触发位置（可能有多个）
    trigger_locations: Vec<Location>,
    
    /// 异步类型
    async_type: AsyncType,
    
    /// 置信度
    confidence: Confidence,
}

/// 异步类型
enum AsyncType {
    /// 简单回调：obj->cb = handler; ... obj->cb();
    SimpleCallback,
    
    /// 注册函数：register_xxx(handler);
    RegisteredCallback {
        register_function: String,
    },
    
    /// 事件循环：handlers[event]();
    EventLoop {
        dispatch_location: Location,
    },
    
    /// 队列：enqueue → dequeue → execute
    Queue {
        enqueue_function: String,
        dequeue_function: String,
    },
    
    /// 已知框架模式
    KnownFramework {
        framework: String,
        pattern: String,
    },
}

/// 置信度
enum Confidence {
    /// 100% 确定（直接赋值、已知框架）
    Certain,
    
    /// 高置信度（清晰的模式）
    High,
    
    /// 中等（有多个可能）
    Medium,
    
    /// 低（推断）
    Low,
    
    /// 不确定（需要用户确认）
    Uncertain,
}

// ============================================
// 执行流数据结构
// ============================================

/// 执行流图
struct ExecutionFlowGraph {
    /// 所有函数节点
    nodes: HashMap<String, FlowNode>,
    
    /// 调用边
    edges: Vec<FlowEdge>,
}

/// 流节点
struct FlowNode {
    /// 函数名
    name: String,
    
    /// 位置
    location: Location,
    
    /// 节点类型
    node_type: NodeType,
}

/// 节点类型
enum NodeType {
    /// 用户定义函数
    UserFunction,
    
    /// 外部函数（库函数）
    External,
    
    /// 异步回调入口
    AsyncCallback {
        async_type: AsyncType,
    },
}

/// 流边
struct FlowEdge {
    /// 调用者
    caller: String,
    
    /// 被调用者
    callee: String,
    
    /// 调用位置
    location: Location,
    
    /// 边类型
    edge_type: EdgeType,
    
    /// 置信度
    confidence: Confidence,
}

/// 边类型
enum EdgeType {
    /// 直接调用
    DirectCall,
    
    /// 间接调用（通过函数指针）
    IndirectCall {
        pointer: Variable,
    },
    
    /// 异步触发
    AsyncTrigger {
        async_type: AsyncType,
    },
}
```

---

## 5. 难点与解决

### 5.1 难点1：外部库调用链

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    难点：外部库调用链                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  问题：                                                                 │
│  ══════                                                                 │
│  当代码调用外部库（如 usb_register），我们看不到库的源码，              │
│  无法知道内部的调用链。                                                 │
│                                                                          │
│  示例：                                                                 │
│  usb_register(&my_driver);  // 我们只看到这一行                        │
│  // 但实际调用链是：                                                    │
│  // usb_register → driver_register → bus_add_driver → ...             │
│  // → 最终某个时候调用 my_driver.probe                                 │
│                                                                          │
│  解决方案：                                                             │
│  ══════════                                                             │
│                                                                          │
│  方案A：知识库（当前主要方案）                                          │
│  ──────────────────────────                                             │
│  • 预置常见库的调用链和异步关系                                         │
│  • 当检测到调用已知库函数时，自动补全信息                               │
│  • 适用：Linux 内核、Android、Qt、libevent 等                          │
│                                                                          │
│  方案B：头文件分析                                                      │
│  ──────────────────────                                                 │
│  • 分析头文件中的函数声明                                               │
│  • 推断函数行为：                                                       │
│    - 参数是 callback 类型 → 可能是注册函数                             │
│    - 函数名包含 register/add/set → 可能是注册函数                      │
│    - 函数名包含 trigger/emit/call → 可能是触发函数                     │
│                                                                          │
│  方案C：用户标注                                                        │
│  ─────────────                                                          │
│  • 当分析不确定时，提示用户                                             │
│  • "这个函数 register_xxx 可能会在何时调用 handler 参数？"             │
│  • 用户选择后，IDE 学习并记住                                           │
│  • 可以导出为知识库分享                                                 │
│                                                                          │
│  方案D：AI 推断（v2.0）                                                 │
│  ───────────────────                                                    │
│  • 根据函数名、参数类型、上下文推断行为                                 │
│  • 标注为"AI 推断"，置信度较低                                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 难点2：复杂控制流

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    难点：复杂控制流                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  问题：                                                                 │
│  ══════                                                                 │
│  函数指针的赋值可能在复杂的控制流中，难以确定。                         │
│                                                                          │
│  示例：                                                                 │
│  void (*fp)(void);                                                      │
│  if (cond1) {                                                           │
│      fp = func_a;                                                       │
│  } else if (cond2) {                                                    │
│      fp = func_b;                                                       │
│  } else {                                                               │
│      fp = func_c;                                                       │
│  }                                                                      │
│  // 循环中                                                              │
│  for (int i = 0; i < n; i++) {                                          │
│      if (arr[i].type == X) fp = func_x;                                 │
│  }                                                                      │
│  fp();  // fp 可能指向 {func_a, func_b, func_c, func_x}                │
│                                                                          │
│  解决方案：                                                             │
│  ══════════                                                             │
│                                                                          │
│  • 流不敏感分析（Flow-insensitive）                                    │
│    - 收集所有可能的赋值，不考虑执行顺序                                 │
│    - 结果：pts(fp) = {func_a, func_b, func_c, func_x}                  │
│    - 优点：简单、快速                                                   │
│    - 缺点：可能过度近似                                                 │
│                                                                          │
│  • 流敏感分析（Flow-sensitive）                                        │
│    - 考虑执行顺序，在每个程序点计算 pts                                 │
│    - 更精确，但更慢                                                     │
│                                                                          │
│  • 路径敏感分析（Path-sensitive）                                      │
│    - 考虑每条路径上的条件                                               │
│    - 最精确，但指数级复杂度                                             │
│                                                                          │
│  FlowSight 策略：                                                       │
│  • 默认使用流不敏感分析                                                 │
│  • 结果展示时，列出所有可能的目标                                       │
│  • 用户可以手动排除不可能的目标                                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.3 难点3：动态数据

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    难点：动态数据                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  问题：                                                                 │
│  ══════                                                                 │
│  有些数据是运行时决定的，静态分析无法确定。                             │
│                                                                          │
│  示例1：数组索引                                                        │
│  void (*handlers[10])(void);                                            │
│  handlers[0] = handler_a;                                               │
│  handlers[1] = handler_b;                                               │
│  ...                                                                    │
│  handlers[runtime_index]();  // runtime_index 运行时才知道             │
│                                                                          │
│  示例2：动态分配                                                        │
│  struct ops *ops = malloc(sizeof(*ops));                                │
│  ops->callback = handler;                                               │
│  // ops 可能有多个实例，每个实例的 callback 不同                        │
│                                                                          │
│  解决方案：                                                             │
│  ══════════                                                             │
│                                                                          │
│  • 数组索引：分析整个数组                                               │
│    - 收集所有对数组的赋值                                               │
│    - handlers[runtime_index]() → 可能调用数组中任何元素                │
│                                                                          │
│  • 堆对象：使用分配点（allocation site）区分                            │
│    - 每个 malloc 调用创建一个抽象对象                                   │
│    - 不同分配点的对象可以区分                                           │
│                                                                          │
│  • 如果无法确定：                                                       │
│    - 标记为"不确定"                                                    │
│    - 提示用户提供更多信息                                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 6. 实现步骤

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       实现路线图                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  阶段1：基础完善 (当前)                              预计：2周          │
│  ═════════════════════                                                  │
│  [x] Tree-sitter 解析器                                                 │
│  [x] 直接调用分析                                                       │
│  [x] 简单函数指针分析                                                   │
│  [x] 已知框架模式匹配（Linux 内核）                                    │
│  [ ] 完善类型分析（识别函数指针类型）                                   │
│                                                                          │
│  阶段2：指针分析增强                                 预计：3周          │
│  ═══════════════════════                                                │
│  [ ] 完整的 Andersen 算法实现                                           │
│  [ ] 结构体字段分析                                                     │
│  [ ] 数组分析                                                           │
│  [ ] 堆对象分析（allocation site）                                     │
│  [ ] 性能优化（增量分析）                                               │
│                                                                          │
│  阶段3：通用异步识别                                 预计：3周          │
│  ═══════════════════════                                                │
│  [ ] 识别函数指针类型的参数和字段                                       │
│  [ ] 追踪绑定-调用关系                                                  │
│  [ ] 常见模式识别（callback, 事件循环, 队列）                          │
│  [ ] 置信度系统                                                         │
│                                                                          │
│  阶段4：头文件分析                                   预计：2周          │
│  ═══════════════════                                                    │
│  [ ] 解析头文件中的函数声明                                             │
│  [ ] 推断函数行为（注册/触发）                                          │
│  [ ] 与知识库结合                                                       │
│                                                                          │
│  阶段5：用户交互                                     预计：2周          │
│  ═══════════════════                                                    │
│  [ ] 不确定时询问用户                                                   │
│  [ ] 用户标注学习                                                       │
│  [ ] 导出为知识库                                                       │
│                                                                          │
│  阶段6：AI 辅助（v2.0）                              预计：4周          │
│  ═══════════════════════                                                │
│  [ ] 函数行为推断                                                       │
│  [ ] 代码意图理解                                                       │
│  [ ] 自然语言解释                                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 7. 准确度评估

### 7.1 各分析阶段的准确度

| 分析类型 | 准确度 | 说明 |
|---------|--------|------|
| 直接调用 | 100% | 语法分析，无歧义 |
| 确定的函数指针赋值 | 100% | `fp = func` 形式 |
| 条件分支下的赋值 | 80-90% | 返回所有可能目标 |
| 结构体字段 | 85-95% | 取决于分析精度 |
| 已知框架模式 | 95-100% | 知识库支持 |
| 通用异步模式 | 70-85% | 取决于代码复杂度 |
| 头文件推断 | 60-75% | 基于启发式规则 |
| AI 推断 | 50-70% | 需要验证 |

### 7.2 整体目标

```
目标：对于典型的 C/C++ 项目

直接调用        ████████████████████ 100%
间接调用        ████████████████░░░░  85%
已知框架异步    ████████████████████  95%
通用异步        ██████████████░░░░░░  75%
外部库调用链    ████████████░░░░░░░░  65% (依赖知识库)

整体目标：让用户理解 80% 以上的执行流程，
对于无法确定的 20%，清晰标注不确定性。
```

### 7.3 与人工阅读的对比

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    FlowSight vs 人工阅读                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  场景：阅读一个 10 万行的 C 项目                                        │
│                                                                          │
│  人工阅读：                                                             │
│  • 时间：资深工程师 2-4 周                                              │
│  • 准确度：取决于工程师水平                                             │
│  • 可能遗漏：隐蔽的 callback 关系                                       │
│  • 需要：丰富的经验                                                     │
│                                                                          │
│  FlowSight：                                                            │
│  • 时间：分析 5-10 分钟                                                 │
│  • 准确度：80-85%（有置信度标注）                                       │
│  • 优势：不会遗漏，覆盖全部代码                                         │
│  • 劣势：无法理解业务逻辑                                               │
│                                                                          │
│  最佳实践：FlowSight 辅助人工阅读                                       │
│  • FlowSight 提供执行流框架                                             │
│  • 人工验证和理解业务逻辑                                               │
│  • 大幅缩短理解代码的时间                                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 附录：参考文献

1. Andersen, L. O. (1994). *Program Analysis and Specialization for the C Programming Language*. PhD thesis.

2. Steensgaard, B. (1996). *Points-to Analysis in Almost Linear Time*. POPL '96.

3. Hardekopf, B., & Lin, C. (2007). *The Ant and the Grasshopper: Fast and Accurate Pointer Analysis for Millions of Lines of Code*. PLDI '07.

4. Sui, Y., & Xue, J. (2016). *SVF: Interprocedural Static Value-Flow Analysis in LLVM*. CC '16.

5. Aho, Lam, Sethi, Ullman. *Compilers: Principles, Techniques, and Tools* (龙书).

---

*文档版本: 1.0*
*最后更新: 2025-01-07*
*作者: FlowSight Team*

